/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 9907:
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ 3696:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LMStudioClient = void 0;
const lms_common_1 = __webpack_require__(2934);
const lms_isomorphic_1 = __webpack_require__(390);
const lms_llm_backend_interface_1 = __webpack_require__(6853);
const lms_system_backend_interface_1 = __webpack_require__(8103);
const chalk_1 = __importDefault(__webpack_require__(8033));
const process_1 = __importDefault(__webpack_require__(9771));
const zod_1 = __webpack_require__(6851);
const createAuthenticatedClientPort_1 = __webpack_require__(9531);
const friendlyErrorDeserializer_1 = __webpack_require__(8488);
const LLMNamespace_1 = __webpack_require__(2392);
const SystemNamespace_1 = __webpack_require__(4600);
const constructorOptsSchema = zod_1.z
    .object({
    logger: zod_1.z.any().optional(),
    baseUrl: zod_1.z.string().optional(),
    verboseErrorMessages: zod_1.z.boolean().optional(),
    clientIdentifier: zod_1.z.string().optional(),
    clientPasskey: zod_1.z.string().optional(),
})
    .strict();
/** @public */
class LMStudioClient {
    /** @internal */
    validateBaseUrlOrThrow(baseUrl) {
        let url;
        try {
            url = new URL(baseUrl);
        }
        catch (e) {
            this.logger.throw((0, lms_common_1.text) `
        Failed to construct LMStudioClient. The baseUrl passed in is invalid. Received: ${baseUrl}
      `);
        }
        if (!["ws:", "wss:"].includes(url.protocol)) {
            this.logger.throw((0, lms_common_1.text) `
        Failed to construct LMStudioClient. The baseUrl passed in must have protocol "ws" or "wss". 
        Received: ${baseUrl}
      `);
        }
        if (url.search !== "") {
            this.logger.throw((0, lms_common_1.text) `
        Failed to construct LMStudioClient. The baseUrl passed contains search parameters
        ("${url.search}").
      `);
        }
        if (url.hash !== "") {
            this.logger.throw((0, lms_common_1.text) `
        Failed to construct LMStudioClient. The baseUrl passed contains a hash ("${url.hash}").
      `);
        }
        if (url.username !== "" || url.password !== "") {
            this.logger.throw((0, lms_common_1.text) `
        Failed to construct LMStudioClient. The baseUrl passed contains a username or password. We
        do not support these in the baseUrl. Received: ${baseUrl}
      `);
        }
        if (baseUrl.endsWith("/")) {
            this.logger.throw((0, lms_common_1.text) `
        Failed to construct LMStudioClient. The baseUrl passed in must not end with a "/". If you
        are reverse-proxying, you should remove the trailing slash from the baseUrl. Received:
        ${baseUrl}
      `);
        }
    }
    async isLocalhostWithGivenPortLMStudioServer(port) {
        const response = await fetch(`http://127.0.0.1:${port}/lmstudio-greeting`);
        if (response.status !== 200) {
            throw new Error("Status is not 200.");
        }
        const json = await response.json();
        if (json?.lmstudio !== true) {
            throw new Error("Not an LM Studio server.");
        }
        return port;
    }
    /**
     * Guess the base URL of the LM Studio server by visiting localhost on various default ports.
     */
    async guessBaseUrl(stack) {
        return Promise.any(lms_common_1.lmsDefaultPorts.map(this.isLocalhostWithGivenPortLMStudioServer)).then(port => `ws://127.0.0.1:${port}`, () => {
            throw (0, lms_common_1.makePrettyError)((0, lms_common_1.text) `
            ${chalk_1.default.redBright("Failed to connect to LM Studio on the default port (1234).")}

            Is LM Studio running? If not, you can start it by running:

                ${chalk_1.default.yellow("lms server start" + (process_1.default.browser ? " --cors=true" : ""))}

            ${chalk_1.default.white("(i) For more information, refer to the LM Studio documentation:")}

                ${chalk_1.default.gray("https://lmstudio.ai/docs/local-server")}
          `, stack);
            // console.error(text`
            //   ${chalk.blueBright(text`
            //     Â· HINT: If you are using a custom port and/or are reverse-proxying, you should pass the
            //     base URL to the LMStudioClient constructor like so:
            //   `)}
            //       ${chalk.cyanBright(text`
            //         const client = new LMStudioClient({ baseUrl: "ws://127.0.0.1:<PORT>" });
            //       `)}
            // `);
            // // We just want to return a promise that never resolves.
            // // This blocks all the API calls.
            // return new Promise(() => undefined);
        });
    }
    constructor(opts = {}) {
        const { logger, baseUrl, verboseErrorMessages, clientIdentifier, clientPasskey } = new lms_common_1.Validator().validateConstructorParamOrThrow("LMStudioClient", "opts", constructorOptsSchema, opts);
        this.logger = new lms_common_1.SimpleLogger("LMStudioClient", logger);
        this.clientIdentifier = clientIdentifier ?? (0, lms_isomorphic_1.generateRandomBase64)(18);
        this.clientPasskey = clientPasskey ?? (0, lms_isomorphic_1.generateRandomBase64)(18);
        const stack = (0, lms_common_1.getCurrentStack)(1);
        let resolvingBaseUrl;
        if (baseUrl === undefined) {
            resolvingBaseUrl = this.guessBaseUrl(verboseErrorMessages ? stack : undefined);
        }
        else {
            this.validateBaseUrlOrThrow(baseUrl);
            resolvingBaseUrl = baseUrl;
        }
        this.llmPort = (0, createAuthenticatedClientPort_1.createAuthenticatedClientPort)((0, lms_llm_backend_interface_1.createLlmBackendInterface)(), resolvingBaseUrl, "llm", this.clientIdentifier, this.clientPasskey, new lms_common_1.SimpleLogger("LLM", this.logger), {
            errorDeserializer: friendlyErrorDeserializer_1.friendlyErrorDeserializer,
            verboseErrorMessage: verboseErrorMessages ?? false,
        });
        this.systemPort = (0, createAuthenticatedClientPort_1.createAuthenticatedClientPort)((0, lms_system_backend_interface_1.createSystemBackendInterface)(), resolvingBaseUrl, "system", this.clientIdentifier, this.clientPasskey, new lms_common_1.SimpleLogger("System", this.logger), {
            errorDeserializer: friendlyErrorDeserializer_1.friendlyErrorDeserializer,
            verboseErrorMessage: verboseErrorMessages ?? false,
        });
        const validator = new lms_common_1.Validator();
        this.llm = new LLMNamespace_1.LLMNamespace(this.llmPort, validator, this.logger);
        this.system = new SystemNamespace_1.SystemNamespace(this.systemPort, this.logger);
    }
}
exports.LMStudioClient = LMStudioClient;
//

/***/ }),

/***/ 9531:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createAuthenticatedClientPort = void 0;
const lms_common_1 = __webpack_require__(2934);
const lms_communication_client_1 = __webpack_require__(3697);
function createAuthenticatedIpcTransportFactory(apiNamespace, hostedEnv, clientIdentifier, clientPasskey) {
    const [onMessage, emitOnMessage] = lms_common_1.BufferedEvent.create();
    const [onClose, emitOnClose] = lms_common_1.BufferedEvent.create();
    const sendToServer = hostedEnv.getApiIpcTunnel(apiNamespace, {
        authVersion: 1,
        clientIdentifier: clientIdentifier,
        clientPasskey: clientPasskey,
    }, emitOnMessage, emitOnClose);
    return lms_communication_client_1.GenericClientTransport.createFactory(onMessage, onClose, sendToServer);
}
function createAuthenticatedWsTransportFactory(apiNamespace, wsAddress, clientIdentifier, clientPasskey) {
    return lms_communication_client_1.AuthenticatedWsClientTransport.createAuthenticatedWsClientTransportFactory({
        url: Promise.resolve(wsAddress).then(wsAddress => `${wsAddress}/${apiNamespace}`),
        clientIdentifier: clientIdentifier,
        clientPasskey: clientPasskey,
    });
}
function createAuthenticatedClientPort(backendInterface, wsAddress, apiNamespace, clientIdentifier, clientPasskey, logger, { errorDeserializer, verboseErrorMessage, } = {}) {
    let anyWindow;
    try {
        anyWindow = window;
    }
    catch (error) {
        anyWindow = undefined;
    }
    if (anyWindow !== undefined && anyWindow.lmsHostedEnv !== undefined) {
        if (wsAddress !== undefined) {
            logger.debug("Ignoring wsAddress parameter when constructing the client because the client is" +
                " running in a hosted environment. This is not an error.");
        }
        return new lms_communication_client_1.ClientPort(backendInterface, createAuthenticatedIpcTransportFactory(apiNamespace, anyWindow.lmsHostedEnv, clientIdentifier, clientPasskey), { parentLogger: logger, errorDeserializer, verboseErrorMessage });
    }
    else {
        return new lms_communication_client_1.ClientPort(backendInterface, createAuthenticatedWsTransportFactory(apiNamespace, wsAddress, clientIdentifier, clientPasskey), { parentLogger: logger, errorDeserializer, verboseErrorMessage });
    }
}
exports.createAuthenticatedClientPort = createAuthenticatedClientPort;
//

/***/ }),

/***/ 8488:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.friendlyErrorDeserializer = void 0;
const lms_common_1 = __webpack_require__(2934);
const lms_shared_types_1 = __webpack_require__(5790);
const chalk_1 = __importDefault(__webpack_require__(8033));
function deserializeOtherError(serialized, stack) {
    let content = chalk_1.default.bgRed.white(` ${serialized.title} `);
    if (serialized.suggestion !== undefined) {
        content +=
            "\n\n\n " +
                chalk_1.default.bgWhite.black("  (!) SUGGESTION  ") +
                "\n\n" +
                chalk_1.default.white(serialized.suggestion);
    }
    if (serialized.cause !== undefined) {
        content +=
            "\n\n\n " + chalk_1.default.bgWhite.black("  (X) CAUSE  ") + "\n\n" + chalk_1.default.gray(serialized.cause);
    }
    return (0, lms_common_1.makePrettyError)(content, stack);
}
const errorDeserializersMap = new Map();
function registerErrorDeserializer(code, deserializer) {
    errorDeserializersMap.set(code, deserializer);
}
function formatAvailableLLMs(availablePathsSample, totalModels) {
    if (availablePathsSample.length === 0) {
        return chalk_1.default.gray("    You don't have any LLMs downloaded.");
    }
    let text = availablePathsSample.map(path => chalk_1.default.cyanBright(" Â· " + path)).join("\n");
    if (availablePathsSample.length < totalModels) {
        text += chalk_1.default.gray(`\n     ... (and ${totalModels - availablePathsSample.length} more)`);
    }
    return text;
}
registerErrorDeserializer("llm.pathNotFound", ({ availablePathsSample, path, totalModels }, stack) => {
    return (0, lms_common_1.makePrettyError)((0, lms_common_1.text) `
        ${chalk_1.default.bgRed.white((0, lms_common_1.text) `
          Cannot find an LLM with path "${chalk_1.default.yellowBright(path)}".
        `)}

        Here are your available LLMs:

        ${formatAvailableLLMs(availablePathsSample, totalModels)}

        Run

            ${chalk_1.default.yellowBright("lms ls")}

        to see a full list of loadable models
      `, stack);
});
function formatLoadedLLMs(loadedModelsSample, totalLoadedModels) {
    if (loadedModelsSample.length === 0) {
        return chalk_1.default.gray("    You don't have any LLMs loaded.");
    }
    let text = loadedModelsSample.map(path => chalk_1.default.cyanBright(" Â· " + path)).join("\n");
    if (loadedModelsSample.length < totalLoadedModels) {
        text += chalk_1.default.gray(`\n     ... (and ${totalLoadedModels - loadedModelsSample.length} more)`);
    }
    return text;
}
registerErrorDeserializer("llm.identifierNotFound", ({ loadedModelsSample, identifier, totalLoadedModels }, stack) => {
    return (0, lms_common_1.makePrettyError)((0, lms_common_1.text) `
        ${chalk_1.default.bgRed.white((0, lms_common_1.text) `
          Cannot find a loaded LLM with identifier "${chalk_1.default.yellowBright(identifier)}".
        `)}

        Here are your loaded LLMs:

        ${formatLoadedLLMs(loadedModelsSample, totalLoadedModels)}

        Run

            ${chalk_1.default.yellowBright("lms ps")}

        to see a full list of loaded models
      `, stack);
});
registerErrorDeserializer("llm.specificModelUnloaded", (_, stack) => {
    return (0, lms_common_1.makePrettyError)(chalk_1.default.bgRed.white((0, lms_common_1.text) `
    This model has already been unloaded.
  `), stack);
});
function formatQuery(query) {
    const requirements = [];
    if (query.identifier !== undefined) {
        requirements.push(`The identifier must be exactly "${chalk_1.default.yellowBright(query.identifier)}"`);
    }
    if (query.path !== undefined) {
        requirements.push(`The path must match "${chalk_1.default.yellowBright(query.path)}"`);
    }
    if (requirements.length === 0) {
        return chalk_1.default.gray(" Â· Any LLM");
    }
    requirements.unshift("The model must be an LLM");
    return requirements.map(req => chalk_1.default.white(" Â· " + req)).join("\n");
}
registerErrorDeserializer("llm.noModelMatchingQuery", ({ query, loadedModelsSample, totalLoadedModels }, stack) => {
    return (0, lms_common_1.makePrettyError)((0, lms_common_1.text) `
        ${chalk_1.default.bgRed.white(" No loaded LLM satisfies all requirements specified in the query. ")}

        Hints:
        
        ${formatQuery(query)}

        Loaded LLMs:

        ${formatLoadedLLMs(loadedModelsSample, totalLoadedModels)}

        Run

            ${chalk_1.default.yellowBright("lms ps")}

        to see a full list of loaded models with details
      `, stack);
});
function friendlyErrorDeserializer(serialized, stack) {
    if (serialized.displayData === undefined) {
        return deserializeOtherError(serialized, stack);
    }
    let error;
    const specificDeserializer = errorDeserializersMap.get(serialized.displayData.code);
    if (specificDeserializer !== undefined) {
        error = specificDeserializer(serialized.displayData);
        (0, lms_shared_types_1.attachSerializedErrorData)(error, serialized);
        return error;
    }
    else {
        return deserializeOtherError(serialized, stack);
    }
}
exports.friendlyErrorDeserializer = friendlyErrorDeserializer;
//

/***/ }),

/***/ 7412:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LMStudioClient = void 0;
var LMStudioClient_1 = __webpack_require__(3696);
Object.defineProperty(exports, "LMStudioClient", ({ enumerable: true, get: function () { return LMStudioClient_1.LMStudioClient; } }));
//

/***/ }),

/***/ 6346:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LLMModel = void 0;
const lms_common_1 = __webpack_require__(2934);
const lms_shared_types_1 = __webpack_require__(5790);
const zod_1 = __webpack_require__(6851);
const OngoingPrediction_1 = __webpack_require__(864);
const completeOptsSchema = zod_1.z.object({
    config: lms_shared_types_1.llmCompletionPredictionConfigSchema.optional(),
    structured: lms_shared_types_1.llmStructuredPredictionSettingSchema.optional(),
});
const respondOptsSchema = zod_1.z.object({
    config: lms_shared_types_1.llmChatPredictionConfigSchema.optional(),
    structured: lms_shared_types_1.llmStructuredPredictionSettingSchema.optional(),
});
/**
 * This represents a set of requirements for a model. It is not tied to a specific model, but rather
 * to a set of requirements that a model must satisfy.
 *
 * For example, if you got the model via `client.llm.get("my-identifier")`, you will get a
 * `LLMModel` for the model with the identifier `my-identifier`. If the model is unloaded, and
 * another model is loaded with the same identifier, using the same `LLMModel` will use the new
 * model.
 *
 * @public
 */
class LLMModel {
    /**
     * Don't construct this on your own. Use {@link LLMNamespace#get} or {@link LLMNamespace#load}
     * instead.
     *
     * @internal
     */
    constructor(
    /** @internal */
    llmPort, 
    /** @internal */
    specifier, validator, parentLogger) {
        this.llmPort = llmPort;
        this.specifier = specifier;
        this.validator = validator;
        this.loaded = true;
        this.logger = new lms_common_1.SimpleLogger(`LLMModel`, parentLogger);
    }
    /** @internal */
    predict(modelSpecifier, history, config, structured, cancelEvent, onFragment, onFinished, onError) {
        const channel = this.llmPort.createChannel("predict", { modelSpecifier, history, config, structured }, message => {
            switch (message.type) {
                case "fragment":
                    onFragment(message.fragment);
                    break;
                case "success":
                    onFinished(message.stats, message.modelInfo);
                    break;
            }
        }, { stack: (0, lms_common_1.getCurrentStack)(2) });
        cancelEvent.subscribeOnce(() => {
            channel.send({ type: "cancel" });
        });
        channel.onError.subscribeOnce(onError);
    }
    /**
     * Use the loaded model to predict text.
     *
     * This method returns an {@link OngoingPrediction} object. An ongoing prediction can be used as a
     * promise (if you only care about the final result) or as an async iterable (if you want to
     * stream the results as they are being generated).
     *
     * Example usage as a promise (Resolves to a {@link PredictionResult}):
     *
     * ```typescript
     * const result = await model.complete("When will The Winds of Winter be released?");
     * console.log(result.content);
     * ```
     *
     * Or
     *
     * ```typescript
     * model.complete("When will The Winds of Winter be released?")
     *  .then(result =\> console.log(result.content))
     *  .catch(error =\> console.error(error));
     * ```
     *
     * Example usage as an async iterable (streaming):
     *
     * ```typescript
     * for await (const fragment of model.complete("When will The Winds of Winter be released?")) {
     *   process.stdout.write(fragment);
     * }
     * ```
     *
     * If you wish to stream the result, but also getting the final prediction results (for example,
     * you wish to get the prediction stats), you can use the following pattern:
     *
     * ```typescript
     * const prediction = model.complete("When will The Winds of Winter be released?");
     * for await (const fragment of prediction) {
     *   process.stdout.write(fragment);
     * }
     * const result = await prediction;
     * console.log(result.stats);
     * ```
     *
     * @param prompt - The prompt to use for prediction.
     * @param opts - Options for the prediction.
     */
    complete(prompt, opts = {}) {
        if (!this.loaded) {
            this.logger.throw("Cannot use `complete` because the model is already unloaded.");
        }
        const stack = (0, lms_common_1.getCurrentStack)(1);
        [prompt, opts] = this.validator.validateMethodParamsOrThrow("model", "complete", ["prompt", "opts"], [zod_1.z.string(), completeOptsSchema], [prompt, opts], stack);
        const { config = {}, structured } = opts;
        const [cancelEvent, emitCancelEvent] = lms_common_1.BufferedEvent.create();
        const { ongoingPrediction, finished, failed, push } = OngoingPrediction_1.OngoingPrediction.create(emitCancelEvent);
        this.predict(this.specifier, [{ role: "user", content: prompt }], {
            // If the user did not specify `stopStrings`, we default to an empty array. This is to
            // prevent the model from using the value set in the preset.
            stopStrings: [],
            ...config,
            // We don't allow the user to set `inputPrefix` and `inputSuffix` in `complete` because it
            // doesn't make sense to do so (and can be vastly confusing.) If the user wants to set these
            // values, they can just include them in the prompt. Here, we just set them to empty strings
            // to prevent the model from using the values set in the preset.
            inputPrefix: "",
            inputSuffix: "",
        }, structured, cancelEvent, fragment => push(fragment), (stats, modelInfo) => finished(stats, modelInfo), error => failed(error));
        return ongoingPrediction;
    }
    /**
     * Use the loaded model to generate a response based on the given history.
     *
     * This method returns an {@link OngoingPrediction} object. An ongoing prediction can be used as a
     * promise (if you only care about the final result) or as an async iterable (if you want to
     * stream the results as they are being generated).
     *
     * Example usage as a promise (Resolves to a {@link PredictionResult}):
     *
     * ```typescript
     * const history = [{ type: 'user', content: "When will The Winds of Winter be released?" }];
     * const result = await model.respond(history);
     * console.log(result.content);
     * ```
     *
     * Or
     *
     * ```typescript
     * const history = [{ type: 'user', content: "When will The Winds of Winter be released?" }];
     * model.respond(history)
     *  .then(result => console.log(result.content))
     *  .catch(error => console.error(error));
     * ```
     *
     * Example usage as an async iterable (streaming):
     *
     * ```typescript
     * const history = [{ type: 'user', content: "When will The Winds of Winter be released?" }];
     * for await (const fragment of model.respond(history)) {
     *   process.stdout.write(fragment);
     * }
     * ```
     *
     * If you wish to stream the result, but also getting the final prediction results (for example,
     * you wish to get the prediction stats), you can use the following pattern:
     *
     * ```typescript
     * const history = [{ type: 'user', content: "When will The Winds of Winter be released?" }];
     * const prediction = model.respond(history);
     * for await (const fragment of prediction) {
     *   process.stdout.write(fragment);
     * }
     * const result = await prediction;
     * console.log(result.stats);
     * ```
     *
     * @param history - The LLMChatHistory array to use for generating a response.
     * @param opts - Options for the prediction.
     */
    respond(history, opts = {}) {
        if (!this.loaded) {
            this.logger.throw("Cannot use `complete` because the model is already unloaded.");
        }
        const stack = (0, lms_common_1.getCurrentStack)(1);
        [history, opts] = this.validator.validateMethodParamsOrThrow("model", "complete", ["history", "opts"], [lms_shared_types_1.llmChatHistorySchema, respondOptsSchema], [history, opts], stack);
        const { config = {}, structured } = opts;
        const [cancelEvent, emitCancelEvent] = lms_common_1.BufferedEvent.create();
        const { ongoingPrediction, finished, failed, push } = OngoingPrediction_1.OngoingPrediction.create(emitCancelEvent);
        this.predict(this.specifier, history, config, structured, cancelEvent, fragment => push(fragment), (stats, modelInfo) => finished(stats, modelInfo), error => failed(error));
        return ongoingPrediction;
    }
    /**
     * Gets the information of the model that is currently associated with this `LLMModel`. If no
     * model is currently associated, this will return `undefined`.
     *
     * Note: As models are loaded/unloaded, the model associated with this `LLMModel` may change at
     * any moment.
     */
    getModelInfo() {
        return this.llmPort.callRpc("getModelInfo", { specifier: this.specifier }, { stack: (0, lms_common_1.getCurrentStack)(1) });
    }
}
exports.LLMModel = LLMModel;
//

/***/ }),

/***/ 2392:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LLMNamespace = void 0;
const lms_common_1 = __webpack_require__(2934);
const lms_shared_types_1 = __webpack_require__(5790);
const zod_1 = __webpack_require__(6851);
const LLMModel_1 = __webpack_require__(6346);
const llmLoadModelOptsSchema = zod_1.z.object({
    preset: zod_1.z.string().optional(),
    identifier: zod_1.z.string().optional(),
    config: lms_shared_types_1.llmLoadModelConfigSchema.optional(),
    acceleration: lms_shared_types_1.llmAccelerationConfigSchema.optional(),
    signal: zod_1.z.instanceof(AbortSignal).optional(),
    verbose: zod_1.z.union([zod_1.z.boolean(), lms_shared_types_1.logLevelSchema]).optional(),
    onProgress: zod_1.z.function().optional(),
    noHup: zod_1.z.boolean().optional(),
});
/** @public */
class LLMNamespace {
    /** @internal */
    constructor(llmPort, validator, parentLogger) {
        this.llmPort = llmPort;
        this.validator = validator;
        this.logger = new lms_common_1.SimpleLogger("Llm", parentLogger);
    }
    /**
     * Load a model for inferencing. The first parameter is the model path. The second parameter is
     * an optional object with additional options. By default, the model is loaded with the default
     * preset (as selected in LM Studio) and the verbose option is set to true.
     *
     * When specifying the model path, you can use the following format:
     *
     * `<publisher>/<repo>[/model_file]`
     *
     * If `model_file` is not specified, the first (sorted alphabetically) model in the repository is
     * loaded.
     *
     * Here are some examples:
     *
     * Loading Gemma 2B:
     *
     * ```typescript
     * const model = await client.llm.load("lmstudio-ai/gemma-2b-it-GGUF");
     * ```
     *
     * Loading a specific quantization (q4_k_m) of Gemma 2B:
     *
     * ```typescript
     * const model = await client.llm.load("lmstudio-ai/gemma-2b-it-GGUF/gemma-2b-it-q4_k_m.gguf");
     * ```
     *
     * To unload the model, you can use the `client.llm.unload` method. Additionally, when the last
     * client with the same `clientIdentifier` disconnects, all models loaded by that client will be
     * automatically unloaded.
     *
     * Once loaded, see {@link LLMModel} for how to use the model for inferencing or other things you
     * can do with the model.
     *
     * @param path - The path of the model to load. See {@link LLMLoadModelOpts} for
     * details.
     * @param opts - Options for loading the model. See {@link LLMLoadModelOpts} for details.
     * @returns A promise that resolves to the model that can be used for inferencing
     */
    async load(path, opts = {}) {
        const stack = (0, lms_common_1.getCurrentStack)(1);
        [path, opts] = this.validator.validateMethodParamsOrThrow("client.llm", "load", ["path", "opts"], [lms_shared_types_1.reasonableKeyStringSchema, llmLoadModelOptsSchema], [path, opts], stack);
        const { preset, identifier, signal, verbose = "info", config, onProgress, noHup } = opts;
        let lastVerboseCallTime = 0;
        const { promise, resolve, reject } = (0, lms_common_1.makePromise)();
        const verboseLevel = typeof verbose === "boolean" ? "info" : verbose;
        const startTime = Date.now();
        if (verbose) {
            this.logger.logAtLevel(verboseLevel, 'Verbose logging is enabled. To hide progress logs, set the "verbose" option to false.');
        }
        const channel = this.llmPort.createChannel("loadModel", {
            path,
            preset,
            identifier,
            config: config ?? {},
            acceleration: opts.acceleration ?? { offload: "auto" },
            noHup: noHup ?? false,
        }, message => {
            switch (message.type) {
                case "success": {
                    if (verbose) {
                        this.logger.logAtLevel(verboseLevel, (0, lms_common_1.text) `
                  Successfully loaded model ${path} in ${Date.now() - startTime}ms
                `);
                    }
                    resolve(new LLMModel_1.LLMModel(this.llmPort, { type: "sessionIdentifier", sessionIdentifier: message.sessionIdentifier }, this.validator, this.logger));
                    break;
                }
                case "progress": {
                    const { progress } = message;
                    if (verbose) {
                        const now = Date.now();
                        if (now - lastVerboseCallTime > 500 || progress === 1) {
                            const progressText = (progress * 100).toFixed(1);
                            this.logger.logAtLevel(verboseLevel, `Loading model ${path}, progress: ${progressText}%`);
                            lastVerboseCallTime = now;
                        }
                    }
                    if (onProgress !== undefined) {
                        onProgress(progress);
                    }
                }
            }
        }, { stack });
        channel.onError.subscribeOnce(reject);
        signal?.addEventListener("abort", () => {
            channel.send({ type: "cancel" });
            reject(signal.reason);
        });
        return promise;
    }
    /**
     * Unload a model. Once a model is unloaded, it can no longer be used. If you wish to use the
     * model afterwards, you will need to load it with {@link LLMNamespace#loadModel} again.
     *
     * @param identifier - The identifier of the model to unload.
     */
    unload(identifier) {
        const stack = (0, lms_common_1.getCurrentStack)(1);
        this.validator.validateMethodParamOrThrow("client.llm", "unload", "identifier", lms_shared_types_1.reasonableKeyStringSchema, identifier, stack);
        return this.llmPort.callRpc("unloadModel", { identifier }, { stack });
    }
    /**
     * List all the currently loaded models.
     */
    listLoaded() {
        const stack = (0, lms_common_1.getCurrentStack)(1);
        return this.llmPort.callRpc("listLoaded", undefined, { stack });
    }
    get(param) {
        const stack = (0, lms_common_1.getCurrentStack)(1);
        this.validator.validateMethodParamOrThrow("client.llm", "get", "param", zod_1.z.union([lms_shared_types_1.reasonableKeyStringSchema, lms_shared_types_1.llmModelQuerySchema]), param, stack);
        let query;
        if (typeof param === "string") {
            query = {
                identifier: param,
            };
        }
        else {
            query = param;
        }
        if (query.path?.includes("\\")) {
            throw (0, lms_common_1.makePrettyError)((0, lms_common_1.text) `
          Model path should not contain backslashes, even if you are on Windows. Use forward
          slashes instead.
        `, stack);
        }
        return new LLMModel_1.LLMModel(this.llmPort, {
            type: "query",
            query,
        }, this.validator, this.logger);
    }
}
exports.LLMNamespace = LLMNamespace;
//

/***/ }),

/***/ 864:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OngoingPrediction = void 0;
const lms_common_1 = __webpack_require__(2934);
const PredictionResult_1 = __webpack_require__(1858);
/**
 * Represents an ongoing prediction.
 *
 * Note, this class is Promise-like, meaning you can use it as a promise. It resolves to a
 * {@link PredictionResult}, which contains the generated text in the `.content` property. Example
 * usage:
 *
 * ```typescript
 * const result = await model.complete("When will The Winds of Winter be released?");
 * console.log(result.content);
 * ```
 *
 * Or you can use instances methods like `then` and `catch` to handle the result or error of the
 * prediction.
 *
 * ```typescript
 * model.complete("When will The Winds of Winter be released?")
 *  .then(result =\> console.log(result.content))
 *  .catch(error =\> console.error(error));
 * ```
 *
 * Alternatively, you can also stream the result (process the results as more content is being
 * generated). For example:
 *
 * ```typescript
 * for await (const fragment of model.complete("When will The Winds of Winter be released?")) {
 *   process.stdout.write(fragment);
 * }
 * ```
 *
 * @public
 */
class OngoingPrediction extends lms_common_1.StreamablePromise {
    async collect(fragments) {
        if (this.stats === null) {
            throw new Error("Stats should not be null");
        }
        if (this.modelInfo === null) {
            throw new Error("Model info should not be null");
        }
        return new PredictionResult_1.PredictionResult(fragments.join(""), this.stats, this.modelInfo);
    }
    constructor(onCancel) {
        super();
        this.onCancel = onCancel;
        this.stats = null;
        this.modelInfo = null;
    }
    /** @internal */
    static create(onCancel) {
        const ongoingPrediction = new OngoingPrediction(onCancel);
        const finished = (stats, modelInfo) => {
            ongoingPrediction.stats = stats;
            ongoingPrediction.modelInfo = modelInfo;
            ongoingPrediction.finished();
        };
        const failed = (error) => ongoingPrediction.finished(error);
        const push = (fragment) => ongoingPrediction.push(fragment);
        return { ongoingPrediction, finished, failed, push };
    }
    /**
     * Get the final prediction results. If you have been streaming the results, awaiting on this
     * method will take no extra effort, as the results are already available in the internal buffer.
     *
     * Example:
     *
     * ```typescript
     * const prediction = model.complete("When will The Winds of Winter be released?");
     * for await (const fragment of prediction) {
     *   process.stdout.write(fragment);
     * }
     * const result = await prediction.result();
     * console.log(result.stats);
     * ```
     *
     * Technically, awaiting on this method is the same as awaiting on the instance itself:
     *
     * ```typescript
     * await prediction.result();
     *
     * // Is the same as:
     *
     * await prediction;
     * ```
     */
    async result() {
        return await this;
    }
    /**
     * Cancels the prediction. This will stop the prediction with stop reason `userStopped`. See
     * {@link LLMPredictionStopReason} for other reasons that a prediction might stop.
     */
    async cancel() {
        this.onCancel();
    }
}
exports.OngoingPrediction = OngoingPrediction;
//

/***/ }),

/***/ 1858:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PredictionResult = void 0;
/**
 * Represents the result of a prediction.
 *
 * The most notably property is {@link PredictionResult#content}, which contains the generated text.
 * Additionally, the {@link PredictionResult#stats} property contains statistics about the
 * prediction.
 *
 * @public
 */
class PredictionResult {
    constructor(
    /**
     * The newly generated text as predicted by the LLM.
     */
    content, 
    /**
     * Statistics about the prediction.
     */
    stats, 
    /**
     * Information about the model used for the prediction.
     */
    modelInfo) {
        this.content = content;
        this.stats = stats;
        this.modelInfo = modelInfo;
    }
}
exports.PredictionResult = PredictionResult;
//

/***/ }),

/***/ 4600:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SystemNamespace = void 0;
const lms_common_1 = __webpack_require__(2934);
/** @public */
class SystemNamespace {
    /** @internal */
    constructor(systemPort, parentLogger) {
        this.systemPort = systemPort;
        this.logger = new lms_common_1.SimpleLogger("System", parentLogger);
    }
    /**
     * TODO: Needs documentation.
     * @public
     */
    async listDownloadedModels() {
        return this.systemPort.callRpc("listDownloadedModels", undefined, {
            stack: (0, lms_common_1.getCurrentStack)(1),
        });
    }
}
exports.SystemNamespace = SystemNamespace;
//

/***/ }),

/***/ 4347:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BufferedEvent = void 0;
const Subscribable_1 = __webpack_require__(5293);
const waitForNextMicroTask = Symbol();
/**
 * A buffered event will buffer events in a queue if no subscribers are present. When a subscriber
 * is added, all buffered events will trigger sequentially in the next microtask.
 *
 * Similar to Event, events are always emitted during the next microtask.
 *
 * Attempting to add more than one subscriber will resulting in an error.
 */
class BufferedEvent extends Subscribable_1.Subscribable {
    static create() {
        const event = new BufferedEvent();
        const emitter = data => {
            event.emit(data);
        };
        return [event, emitter];
    }
    constructor() {
        super();
        this.subscriber = null;
        this.queued = [];
        this.isNotifying = false;
    }
    emit(data) {
        if (this.queued.length === 0 && this.queued.at(-1) !== waitForNextMicroTask) {
            this.queued.push(waitForNextMicroTask);
        }
        this.queued.push(data);
        if (!this.isNotifying) {
            this.notifier();
        }
    }
    async notifier() {
        this.isNotifying = true;
        while (this.subscriber !== null && this.queued.length > 0) {
            const data = this.queued.shift();
            if (data === waitForNextMicroTask) {
                await Promise.resolve();
            }
            else {
                this.subscriber(data);
            }
        }
        this.isNotifying = false;
    }
    subscribe(listener) {
        if (this.subscriber !== null) {
            throw new Error("Cannot have more than one subscriber");
        }
        this.subscriber = listener;
        if (!this.isNotifying && this.queued.length > 0) {
            this.queued = [
                waitForNextMicroTask,
                ...this.queued.filter(data => data !== waitForNextMicroTask),
            ];
            this.notifier();
        }
        return () => {
            this.subscriber = null;
        };
    }
}
exports.BufferedEvent = BufferedEvent;
//

/***/ }),

/***/ 2926:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Event = void 0;
const Subscribable_1 = __webpack_require__(5293);
/**
 * Represents an event that can be subscribed to. Emitted events will trigger all subscribers in the
 * next microtask. If multiple events are emitted, they will be triggered in the same microtask.
 */
class Event extends Subscribable_1.Subscribable {
    constructor() {
        super();
        this.subscribers = new Set();
    }
    emit(data) {
        queueMicrotask(() => {
            for (const subscriber of this.subscribers) {
                subscriber(data);
            }
        });
    }
    static create() {
        const event = new Event();
        const emitter = data => {
            event.emit(data);
        };
        return [event, emitter];
    }
    subscribe(listener) {
        this.subscribers.add(listener);
        return () => {
            this.subscribers.delete(listener);
        };
    }
}
exports.Event = Event;
//

/***/ }),

/***/ 1322:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LazySignal = void 0;
const Signal_1 = __webpack_require__(9484);
const Subscribable_1 = __webpack_require__(5293);
const makePromise_1 = __webpack_require__(1245);
/**
 * A lazy signal is a signal that will only subscribe to the upstream when at least one subscriber
 * is attached. It will unsubscribe from the upstream when the last subscriber is removed.
 *
 * A lazy signal can possess a special value "NOT_AVAILABLE", accessible from the static property
 * {@link LazySignal.NOT_AVAILABLE}. This value is used to indicate that the value is not available
 * yet. This can happen when the signal is created without an initial value and the upstream has not
 * emitted a value yet.
 */
class LazySignal extends Subscribable_1.Subscribable {
    static create(initialValue, upstreamSubscriber, equalsPredicate = (a, b) => a === b) {
        return new LazySignal(initialValue, upstreamSubscriber, equalsPredicate);
    }
    static createWithoutInitialValue(upstreamSubscriber, equalsPredicate = (a, b) => a === b) {
        const fullEqualsPredicate = (a, b) => {
            if (a === LazySignal.NOT_AVAILABLE || b === LazySignal.NOT_AVAILABLE) {
                return a === b;
            }
            return equalsPredicate(a, b);
        };
        return new LazySignal(LazySignal.NOT_AVAILABLE, upstreamSubscriber, fullEqualsPredicate);
    }
    constructor(initialValue, upstreamSubscriber, equalsPredicate = (a, b) => a === b) {
        super();
        this.upstreamSubscriber = upstreamSubscriber;
        this.dataIsStale = true;
        this.upstreamUnsubscribe = null;
        this.subscribersCount = 0;
        [this.signal, this.setValue] = Signal_1.Signal.create(initialValue, equalsPredicate);
    }
    /**
     * Returns whether the value is currently stale.
     *
     * A value is stale whenever the upstream subscription is not active. This can happen in two
     * cases:
     *
     * 1. When no subscriber is attached to this signal, the signal will not subscribe to the
     *    upstream. In this case, the value is always stale.
     * 2. When a subscriber is attached, but the upstream has not yet emitted a single value, the
     *    value is also stale.
     *
     * If you wish to get the current value and esnure that it is not stale, use the method
     * {@link LazySignal#pull}.
     */
    isStale() {
        return this.dataIsStale;
    }
    subscribeToUpstream() {
        this.upstreamUnsubscribe = this.upstreamSubscriber(data => {
            this.dataIsStale = false;
            this.setValue(data);
        });
    }
    unsubscribeFromUpstream() {
        if (this.upstreamUnsubscribe !== null) {
            this.upstreamUnsubscribe();
            this.upstreamUnsubscribe = null;
            this.dataIsStale = true;
        }
    }
    /**
     * Gets the current value of the signal. If the value is not available, it will return
     * {@link LazySignal.NOT_AVAILABLE}. In addition, the value returned by this method may be stale.
     * Use {@link LazySignal#isStale} to check if the value is stale.
     *
     * If you wish to get the current value and ensure that it is not stale, use the method
     * {@link LazySignal#pull}.
     */
    get() {
        return this.signal.get();
    }
    /**
     * Pulls the current value of the signal. If the value is stale, it will wait for the next value
     * from the upstream and return it.
     */
    async pull() {
        const { promise, resolve } = (0, makePromise_1.makePromise)();
        if (!this.isStale()) {
            // If not stale, definitely not "NOT_AVAILABLE"
            resolve(this.get());
        }
        this.subscribeOnce(data => {
            resolve(data);
        });
        return promise;
    }
    subscribe(callback) {
        if (this.subscribersCount === 0) {
            this.subscribeToUpstream();
        }
        this.subscribersCount++;
        const unsubscribe = this.signal.subscribe(callback);
        let unsubscribeCalled = false;
        return () => {
            if (unsubscribeCalled) {
                return;
            }
            unsubscribe();
            unsubscribeCalled = true;
            this.subscribersCount--;
            if (this.subscribersCount === 0) {
                this.unsubscribeFromUpstream();
            }
        };
    }
}
exports.LazySignal = LazySignal;
LazySignal.NOT_AVAILABLE = Symbol("notAvailable");
//

/***/ }),

/***/ 9484:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Signal = void 0;
const immer_1 = __webpack_require__(6392);
const Subscribable_1 = __webpack_require__(5293);
const notQueued = Symbol("notQueued");
const equals = (a, b) => a === b;
/**
 * A signal is a wrapper for a value. It can be used to notify subscribers when the value changes.
 * For it to work properly, the value should be immutable.
 *
 * To create a signal, please use the `Signal.create` static method. It will return a signal
 * along with a function to update its value.
 */
class Signal extends Subscribable_1.Subscribable {
    /**
     * Creates a signal.
     *
     * @param value - The initial value of the signal.
     * @param equalsPredicate - A function to compare two values. The subscribers will only be called
     * if the value changes according to the `equalsPredicate`. By default, it uses the `===`
     * operator.
     * @returns This method returns a tuple with two elements:
     * - The signal
     * - A function to update the value
     **/
    static create(value, equalsPredicate = equals) {
        const signal = new Signal(value, equalsPredicate);
        const setValue = (value) => {
            signal.set(value, [
                {
                    op: "replace",
                    path: [],
                    value,
                },
            ]);
        };
        setValue.withImmer = signal.setWithImmer.bind(signal);
        return [signal, setValue];
    }
    constructor(value, equalsPredicate) {
        super();
        this.value = value;
        this.equalsPredicate = equalsPredicate;
        this.subscribers = new Set();
        this.queuedUpdate = notQueued;
        this.queuedPatches = [];
        this.isEmitting = false;
    }
    /**
     * Returns the current value of the signal.
     */
    get() {
        return this.value;
    }
    notify(value) {
        for (const subscriber of this.subscribers) {
            subscriber(value);
        }
    }
    notifyAndUpdateIfChanged(value) {
        if (!this.equalsPredicate(this.value, value)) {
            this.value = value;
            this.notify(value);
        }
    }
    makeReplaceRootPatch(value) {
        return {
            op: "replace",
            path: [],
            value,
        };
    }
    set(value, patches) {
        if (this.isEmitting) {
            // It is already emitting, so we should queue the update.
            this.queuedUpdate = value;
            if (patches === undefined) {
                this.queuedPatches = [this.makeReplaceRootPatch(value)];
            }
            else {
                this.queuedPatches.push(...patches);
            }
            return;
        }
        this.isEmitting = true;
        try {
            this.notifyAndUpdateIfChanged(value);
            while (this.queuedUpdate !== notQueued) {
                const queuedValue = this.queuedUpdate;
                this.queuedUpdate = notQueued;
                this.notifyAndUpdateIfChanged(queuedValue);
            }
        }
        finally {
            this.isEmitting = false;
        }
    }
    setWithImmer(producer) {
        const [updated, patch] = (0, immer_1.produceWithPatches)(this.value, producer);
        this.set(updated, patch);
    }
    /**
     * Subscribes to the signal. The callback will be called whenever the value changes. All callbacks
     * are called synchronously upon updating. It will NOT be immediately called with the current
     * value. (Use `get()` to get the current value.) Returns a function to unsubscribe.
     *
     * Edge cases involving manipulating the signal in the callback:
     *
     * - If the callback adds new subscribers, they will also be called within the same update.
     * - If the callback causes removal of subscribers that have not been called yet, they will no
     *   longer be called.
     * - If the callback causes an update of the value, the update will be queued. If multiple updates
     *   are queued, only the last one will be executed.
     *
     * Edge cases involving adding the same callback multiple times.
     *
     *  - Callbacks are tracked with a set. Adding the same subscriber will not cause it to be called
     *    multiple times.
     */
    subscribe(callback) {
        this.subscribers.add(callback);
        return () => {
            this.subscribers.delete(callback);
        };
    }
}
exports.Signal = Signal;
//

/***/ }),

/***/ 7830:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleLogger = void 0;
const chalk_1 = __importDefault(__webpack_require__(8033));
const text_1 = __webpack_require__(7087);
const infoPrefix = chalk_1.default.greenBright("I");
const warnPrefix = chalk_1.default.yellowBright("W");
const errorPrefix = chalk_1.default.redBright("E");
const debugPrefix = chalk_1.default.blueBright("D");
function isSimpleLogger(logger) {
    return logger?.isSimpleLogger === true;
}
class SimpleLogger {
    constructor(prefixText = "", parentLogger = console) {
        this.isSimpleLogger = true;
        if (isSimpleLogger(parentLogger)) {
            if (prefixText === "") {
                this.innerPrefix = parentLogger.innerPrefix;
                this.fullPrefix = parentLogger.fullPrefix;
            }
            else {
                if (parentLogger.fullPrefix === "") {
                    this.innerPrefix = prefixText;
                }
                else {
                    this.innerPrefix = `${parentLogger.innerPrefix}][${prefixText}`;
                }
                this.fullPrefix = chalk_1.default.whiteBright(`[${this.innerPrefix}]`);
            }
            this.parentLogger = parentLogger.parentLogger;
        }
        else {
            if (prefixText === "") {
                this.innerPrefix = "";
                this.fullPrefix = "";
            }
            else {
                this.innerPrefix = prefixText;
                this.fullPrefix = chalk_1.default.whiteBright(`[${this.innerPrefix}]`);
            }
            this.parentLogger = parentLogger;
        }
    }
    subclass(prefixText) {
        return new SimpleLogger(`${this.innerPrefix}:${prefixText}`, this.parentLogger);
    }
    info(...messages) {
        this.parentLogger.info(infoPrefix, this.fullPrefix, ...messages);
    }
    infoText(strings, ...values) {
        this.info((0, text_1.text)(strings, ...values));
    }
    infoWithoutPrefix(...messages) {
        this.parentLogger.info(...messages);
    }
    error(...messages) {
        this.parentLogger.error(errorPrefix, this.fullPrefix, ...messages);
    }
    errorText(strings, ...values) {
        this.error((0, text_1.text)(strings, ...values));
    }
    errorWithoutPrefix(...messages) {
        this.parentLogger.error(...messages);
    }
    warn(...messages) {
        this.parentLogger.warn(warnPrefix, this.fullPrefix, ...messages);
    }
    warnText(strings, ...values) {
        this.warn((0, text_1.text)(strings, ...values));
    }
    warnWithoutPrefix(...messages) {
        this.parentLogger.warn(...messages);
    }
    debug(...messages) {
        this.parentLogger.debug(debugPrefix, this.fullPrefix, ...messages);
    }
    debugText(strings, ...values) {
        this.debug((0, text_1.text)(strings, ...values));
    }
    debugWithoutPrefix(...messages) {
        this.parentLogger.debug(...messages);
    }
    throw(message) {
        throw new Error(`${this.fullPrefix} ${message}`);
    }
    logAtLevel(level, ...messages) {
        switch (level) {
            case "debug":
                this.debug(...messages);
                break;
            case "info":
                this.info(...messages);
                break;
            case "warn":
                this.warn(...messages);
                break;
            case "error":
                this.error(...messages);
                break;
        }
    }
}
exports.SimpleLogger = SimpleLogger;
//

/***/ }),

/***/ 3935:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StreamablePromise = void 0;
const makePromise_1 = __webpack_require__(1245);
const finished = Symbol("finished");
/**
 * A StreamablePromise is a promise-like that is also async iterable. This means you can use it as a
 * promise (awaiting it, using `.then`, `.catch`, etc.), and you can also use it as an async
 * iterable (using `for await`).
 *
 * Notably, as much as it implements the async iterable interface, it is not a traditional iterable,
 * as it internally maintains a buffer and new values are pushed into the buffer by the producer, as
 * oppose to being pulled by the consumer.
 *
 * The async iterable interface is used instead of the Node.js object stream because streams are too
 * clunky to use, and the `for await` syntax is much more ergonomic for most people.
 *
 * If any iterator is created for this instance, an empty rejection handler will be attached to the
 * promise to prevent unhandled rejection warnings.
 *
 * This class is provided as an abstract class and is meant to be extended. Crucially, the `collect`
 * method must be implemented, which will be called to convert an array of values into the final
 * resolved value of the promise.
 *
 * In addition, the constructor of the subclass should be marked as private, and a static method
 * that exposes the constructor, the `finished` method, and the `push` method should be provided.
 *
 * @typeParam TFragment - The type of the individual fragments that are pushed into the buffer.
 * @typeParam TFinal - The type of the final resolved value of the promise.
 * @public
 */
class StreamablePromise {
    /**
     * Called by the producer when it has finished producing values. If an error is provided, the
     * promise will be rejected with that error. If no error is provided, the promise will be resolved
     * with the final value.
     *
     * This method should be exposed in the static constructor of the subclass.
     *
     * @param error - The error to reject the promise with, if any.
     */
    finished(error) {
        if (this.status !== "pending") {
            throw new Error("`finished` called while not pending");
        }
        if (error === undefined) {
            this.status = "resolved";
            this.nextFragmentPromiseBundle?.resolve(finished);
            this.resolveFinal(this.collect(this.buffer));
        }
        else {
            this.status = "rejected";
            this.nextFragmentPromiseBundle?.reject(error);
            this.rejectFinal(error);
        }
    }
    /**
     * Called by the producer to push a new fragment into the buffer. This method should be exposed in
     * the static constructor of the subclass.
     *
     * This method should be exposed in the static constructor of the subclass.
     *
     * @param fragment - The fragment to push into the buffer.
     */
    push(fragment) {
        if (this.status !== "pending") {
            throw new Error("`push` called while not pending");
        }
        this.buffer.push(fragment);
        this.nextFragmentPromiseBundle?.resolve(fragment);
        this.nextFragmentPromiseBundle = null;
    }
    constructor() {
        this.status = "pending";
        this.buffer = [];
        this.nextFragmentPromiseBundle = null;
        /**
         * If there has ever been any iterators created for this instance. Once any iterator is created,
         * a reject handler will be attached to the promise to prevent unhandled rejection warnings, as
         * the errors will be handled by the iterator.
         *
         * The purpose of this variable is to prevent registering the reject handler more than once.
         */
        this.hasIterator = false;
        this[_a] = "StreamablePromise";
        const { promise, resolve, reject } = (0, makePromise_1.makePromise)();
        this.promiseFinal = promise;
        this.resolveFinal = resolve;
        this.rejectFinal = reject;
    }
    then(onfulfilled, onrejected) {
        return this.promiseFinal.then(onfulfilled, onrejected);
    }
    catch(onrejected) {
        return this.promiseFinal.catch(onrejected);
    }
    finally(onfinally) {
        return this.promiseFinal.finally(onfinally);
    }
    /**
     * If nextFragmentPromiseBundle exists, it is returned. Otherwise, a new one is created and
     * returned.
     */
    obtainNextFragmentPromiseBundle() {
        if (this.nextFragmentPromiseBundle === null) {
            this.nextFragmentPromiseBundle = (0, makePromise_1.makePromise)();
        }
        return this.nextFragmentPromiseBundle;
    }
    async *[(_a = Symbol.toStringTag, Symbol.asyncIterator)]() {
        if (!this.hasIterator) {
            this.promiseFinal.catch(() => { }); // Prevent unhandled rejection warning
            this.hasIterator = true;
        }
        let i = 0;
        while (this.status === "pending") {
            if (i < this.buffer.length) {
                yield this.buffer[i];
                i++;
            }
            else {
                const nextFragmentPromiseBundle = this.obtainNextFragmentPromiseBundle();
                const nextFragment = await nextFragmentPromiseBundle.promise;
                if (nextFragment === finished) {
                    break;
                }
                yield nextFragment;
                i++;
            }
        }
    }
}
exports.StreamablePromise = StreamablePromise;
//

/***/ }),

/***/ 5293:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Subscribable = void 0;
const LazySignal_1 = __webpack_require__(1322);
/**
 * Base class for objects that can be subscribed to. Provides common utility methods.
 */
class Subscribable {
    subscribeOnce(listener) {
        const unsubscribe = this.subscribe(data => {
            unsubscribe();
            listener(data);
        });
        return unsubscribe;
    }
    deriveLazySignal(deriver, outputEqualsPredicate = (a, b) => a === b) {
        const thisWithGetter = this;
        if (thisWithGetter.get !== undefined) {
            return LazySignal_1.LazySignal.create(deriver(thisWithGetter.get()), listener => {
                return this.subscribe(data => {
                    listener(deriver(data));
                });
            }, outputEqualsPredicate);
        }
        return LazySignal_1.LazySignal.createWithoutInitialValue(listener => {
            return this.subscribe(data => {
                listener(deriver(data));
            });
        }, outputEqualsPredicate);
    }
}
exports.Subscribable = Subscribable;
//

/***/ }),

/***/ 4013:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeoutTracker = void 0;
const BufferedEvent_1 = __webpack_require__(4347);
class TimeoutTracker {
    constructor(timeoutMs) {
        this.timeoutMs = timeoutMs;
        this.started = false;
        this.timeout = null;
        [this.triggeredEvent, this.emitTriggeredEvent] = BufferedEvent_1.BufferedEvent.create();
    }
    reset() {
        if (!this.started) {
            return;
        }
        if (this.timeout !== null) {
            clearTimeout(this.timeout);
        }
        this.timeout = setTimeout(() => {
            this.emitTriggeredEvent();
            if (this.timeout !== null) {
                clearTimeout(this.timeout);
            }
        }, this.timeoutMs);
    }
    start() {
        this.started = true;
        this.reset();
    }
    stop() {
        if (this.timeout !== null) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
        this.started = false;
    }
}
exports.TimeoutTracker = TimeoutTracker;
//

/***/ }),

/***/ 3496:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Validator = void 0;
const chalk_1 = __importDefault(__webpack_require__(8033));
const makePrettyError_1 = __webpack_require__(7578);
const text_1 = __webpack_require__(7087);
class Validator {
    constructor({ attachStack } = {}) {
        this.attachStack = attachStack ?? true;
    }
    /**
     * Pretty-prints a Zod error.
     *
     * @param rootObjectName - The name of the object being validated (used for error messages)
     * @param error - The Zod error to pretty-print
     *
     * @returns The pretty-printed error in a string
     */
    static prettyPrintZod(rootObjectName, error) {
        return error.errors
            .map(e => {
            if (e.path.length === 0) {
                return `- ${chalk_1.default.redBright(rootObjectName)}: ${e.message}`;
            }
            const path = chalk_1.default.red(`.${e.path.join(".")}`);
            return `- ${chalk_1.default.redBright(rootObjectName)}${path}: ${e.message}`;
        })
            .join("\n");
    }
    /**
     * Validates a value against a schema and throws an error if it's invalid.
     *
     * @param lead - The start of the error message (used for error messages)
     * @param rootObjectName - The name of the object being validated (used for error messages)
     * @param schema - The schema to validate against
     * @param value - The value to validate
     *
     * @returns The validated value
     * @throws An error if the value is invalid
     */
    validateOrThrow(lead, rootObjectName, schema, value, stack) {
        const result = schema.safeParse(value);
        if (result.success) {
            return result.data;
        }
        else {
            throw (0, makePrettyError_1.makePrettyError)(`${lead}\n\n${Validator.prettyPrintZod(rootObjectName, result.error)}`, this.attachStack ? stack : undefined);
        }
    }
    /**
     * Validates multiple values against multiple schemas and throws an error if any of them are
     * invalid. All values are validated before any errors are thrown. This is useful when you want to
     * validate multiple values at once and want to see all the errors at once.
     *
     * @param leadProducer - The function to produce the start of the error message (used for error).
     * It is called with a set of indices of the invalid values.
     * @param rootObjectNames - The names of the objects being validated (used for error messages)
     * @param schemas - The schemas to validate against
     * @param values - The values to validate
     *
     * @returns The validated values
     * @throws An error if any of the values are invalid
     */
    validateMultipleOrThrow(leadProducer, rootObjectNames, schemas, values, stack) {
        const results = schemas.map((schema, index) => schema.safeParse(values[index]));
        const errors = results
            .map((result, index) => ({ result, index, rootObjectName: rootObjectNames[index] }))
            .filter(({ result }) => !result.success)
            .map(({ result, rootObjectName, index }) => ({
            error: result.error,
            rootObjectName,
            index,
        }));
        if (errors.length === 0) {
            return values;
        }
        else {
            const erroredValues = new Set(errors.map(({ index }) => index));
            const lead = leadProducer(erroredValues);
            throw (0, makePrettyError_1.makePrettyError)(`${lead}\n\n${errors
                .map(({ error, rootObjectName }) => Validator.prettyPrintZod(rootObjectName, error))
                .join("\n")}`, this.attachStack ? stack : undefined);
        }
    }
    /**
     * Validates a value against a schema and throws an error if it's invalid. This is a convenience
     * function for validating one single method parameter.
     *
     * @param className - The name of the class containing the method (used for error messages)
     * @param methodName - The name of the method (used for error messages)
     * @param paramName - The name of the parameter being validated (used for error messages)
     * @param schema - The schema to validate against
     * @param value - The value to validate
     *
     * @returns The validated value
     * @throws An error if the value is invalid
     */
    validateMethodParamOrThrow(className, methodName, paramName, schema, value, stack) {
        const functionCall = chalk_1.default.yellowBright((0, text_1.text) `
    ${className}.${methodName}(${chalk_1.default.redBright(paramName)})
  `);
        return this.validateOrThrow(`Invalid parameter(s) for ${functionCall}:`, paramName, schema, value, stack);
    }
    /**
     * Validates multiple values against multiple schemas and throws an error if any of them are
     * invalid. This is a convenience function for validating multiple method parameters.
     *
     * @param className - The name of the class containing the method (used for error messages)
     * @param methodName - The name of the method (used for error messages)
     * @param paramNames - The names of the parameters being validated (used for error messages)
     * @param schemas - The schemas to validate against
     * @param values - The values to validate
     *
     * @returns The validated values
     * @throws An error if any of the values are invalid
     */
    validateMethodParamsOrThrow(className, methodName, paramNames, schemas, values, stack) {
        return this.validateMultipleOrThrow(erroredValues => {
            const coloredParamNames = paramNames.map((name, index) => erroredValues.has(index) ? chalk_1.default.redBright(name) : name);
            const functionCall = chalk_1.default.yellowBright((0, text_1.text) `
        ${className}.${methodName}(${coloredParamNames.join(", ")})
      `);
            return `Invalid parameter(s) for ${functionCall}:`;
        }, paramNames, schemas, values, stack);
    }
    /**
     * Validates a value against a schema and throws an error if it's invalid. This is a convenience
     * function for validating one single constructor parameter.
     *
     * @param className - The name of the class (used for error messages)
     * @param paramName - The name of the parameter being validated (used for error messages)
     * @param schema - The schema to validate against
     * @param value - The value to validate
     *
     * @returns The validated value
     * @throws An error if the value is invalid
     */
    validateConstructorParamOrThrow(className, paramName, schema, value, stack) {
        const functionCall = chalk_1.default.yellowBright((0, text_1.text) `
    ${className}(${chalk_1.default.redBright(paramName)})
  `);
        return this.validateOrThrow(`Invalid parameter(s) when constructing ${functionCall}`, paramName, schema, value, stack);
    }
    /**
     * Validates multiple values against multiple schemas and throws an error if any of them are
     * invalid. This is a convenience function for validating multiple constructor parameters.
     *
     * @param className - The name of the class (used for error messages)
     * @param paramNames - The names of the parameters being validated (used for error messages)
     *
     * @param schemas - The schemas to validate against
     * @param values - The values to validate
     */
    validateConstructorParamsOrThrow(className, paramNames, schemas, values, stack) {
        return this.validateMultipleOrThrow(erroredValues => {
            const coloredParamNames = paramNames.map((name, index) => erroredValues.has(index) ? chalk_1.default.redBright(name) : name);
            const functionCall = chalk_1.default.yellowBright((0, text_1.text) `
        ${className}(${coloredParamNames.join(", ")})
      `);
            return `Invalid parameter(s) when constructing ${functionCall}:`;
        }, paramNames, schemas, values, stack);
    }
}
exports.Validator = Validator;
//

/***/ }),

/***/ 8162:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Holder = exports.Pager = exports.WaitQueue = exports.QueueClearedError = exports.PagerExitedError = void 0;
const SimpleLogger_1 = __webpack_require__(7830);
const makePromise_1 = __webpack_require__(1245);
const resolvePager = Symbol("resolvePager");
const rejectPager = Symbol("rejectPager");
const dropHolder = Symbol("dropHolder");
const getLogger = Symbol("logger");
const removePager = Symbol("removePager");
class PagerExitedError extends Error {
    constructor() {
        super("Pager has been exited");
    }
}
exports.PagerExitedError = PagerExitedError;
class QueueClearedError extends Error {
    constructor() {
        super("Queue has been cleared");
    }
}
exports.QueueClearedError = QueueClearedError;
/**
 * WaitQueue is a queue that can be used to wait for a resource to become available.
 *
 * It is similar to going to a busy restaurant in that you get a pager (the plastic thing that has a
 * red LED on it), which will beep when your table is ready.
 *
 * The {@link WaitQueue#enterQueue} method is used to get a pager, and the Pager object that is
 * returned can be waited on using the {@link Pager#wait} method, which returns a promise that
 * resolves to a {@link Holder} object. When you are done, {@link Holder#drop} should be called to
 * release the resource. Alternatively, the `using` keyword can be used to automatically release the
 * resource when the block is exited.
 *
 * Queue can be exited with the {@link Pager#exit} method.
 */
class WaitQueue {
    constructor(parentLogger) {
        this.pagers = [];
        this.finalizationRegistry = new FinalizationRegistry(() => {
            this.logger.warnText `
      A holder has been finalized without being dropped! FinalizationRegistry is the last resort
      and should not be relied upon. Please make sure to always drop the holder when you are done
      with it.
    `;
            this.currentlyServing = null;
            this.tryAdvancingQueue();
        });
        this.currentlyServing = null;
        this.logger = new SimpleLogger_1.SimpleLogger("WaitQueue", parentLogger);
    }
    /**
     * Enters the queue and returns a pager that can be waited on.
     *
     * @param priority - The priority of the pager. Lower numbers are served first. Defaults to 0.
     */
    enterQueue(priority = 0) {
        const pager = new Pager(this, priority);
        this.pagers.push(pager);
        this.pagers.sort((a, b) => (a.priority < b.priority ? -1 : a.priority > b.priority ? 1 : 0));
        this.tryAdvancingQueue();
        return pager;
    }
    tryAdvancingQueue() {
        if (this.currentlyServing === null) {
            const pager = this.pagers.shift();
            if (pager !== undefined) {
                this.currentlyServing = pager;
                const holder = new Holder(this);
                this.finalizationRegistry.register(holder, undefined, holder);
                pager[resolvePager](holder);
            }
        }
    }
    clearQueue(error = new QueueClearedError()) {
        for (const pager of this.pagers) {
            pager[rejectPager](error);
        }
        this.pagers.length = 0;
    }
    /** @internal */
    [dropHolder](holder) {
        this.finalizationRegistry.unregister(holder);
        this.currentlyServing = null;
        this.tryAdvancingQueue();
    }
    /** @internal */
    [getLogger]() {
        return this.logger;
    }
    /** @internal */
    [removePager](pager) {
        const index = this.pagers.indexOf(pager);
        if (index !== -1) {
            this.pagers.splice(index, 1);
        }
        else {
            this.logger.warnText `
        A pager was removed from the queue, but it was not in the queue. This is a bug in the code
        that uses the WaitQueue.
      `;
        }
    }
}
exports.WaitQueue = WaitQueue;
class Pager {
    /** @internal */
    constructor(queue, priority) {
        this.queue = queue;
        this.priority = priority;
        const { promise, resolve, reject } = (0, makePromise_1.makePromise)();
        this.waitingPromise = promise;
        this.resolveWaitingPromise = resolve;
        this.rejectWaitingPromise = reject;
    }
    /** @internal */
    [resolvePager](holder) {
        this.resolveWaitingPromise(holder);
    }
    /** @internal */
    [rejectPager](error) {
        this.rejectWaitingPromise(error);
    }
    wait() {
        return this.waitingPromise;
    }
    exit(error = new PagerExitedError()) {
        this.queue[removePager](this);
        this[rejectPager](error);
    }
}
exports.Pager = Pager;
class Holder {
    /** @internal */
    constructor(queue) {
        this.queue = queue;
        this.dropped = false;
    }
    drop() {
        if (this.dropped) {
            this.queue[getLogger]().throw("Holder has already been dropped. This is a bug in the code that uses the WaitQueue.");
        }
        this.dropped = true;
        this.queue[dropHolder](this);
    }
    [Symbol.dispose]() {
        this.drop();
    }
}
exports.Holder = Holder;
//

/***/ }),

/***/ 2130:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(9907);

// Error stack manipulation related functions
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.changeErrorStackInPlace = exports.getCurrentStack = void 0;
function getCurrentStack(goAbove = 0) {
    const stack = new Error().stack;
    if (!stack) {
        return "";
    }
    const lines = stack.split("\n");
    return lines.slice(2 + goAbove).join("\n");
}
exports.getCurrentStack = getCurrentStack;
function changeErrorStackInPlace(error, newStack) {
    if (process.env.LMS_KEEP_INTERNAL_STACK) {
        return;
    }
    const stackContent = error.stack ?? "";
    error.stack = (stackContent.substring(0, stackContent.indexOf("\n    at ")).trimEnd() +
        "\n" +
        newStack).trimEnd();
}
exports.changeErrorStackInPlace = changeErrorStackInPlace;
//

/***/ }),

/***/ 2934:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.filteredArray = exports.failOk = exports.WaitQueue = exports.QueueClearedError = exports.PagerExitedError = exports.Validator = exports.toJSONSafeNumber = exports.TimeoutTracker = exports.text = exports.StreamablePromise = exports.SimpleLogger = exports.Signal = exports.runOnDispose = exports.unwrapPromiseOfResult = exports.unwrapPromiseOfMaybeErrored = exports.promiseToResult = exports.promiseToMaybeErrored = exports.maybeErroredSchema = exports.createResultSchema = exports.removeUndefinedValues = exports.makePromise = exports.makeTitledPrettyError = exports.makePrettyError = exports.lmsDefaultPorts = exports.Event = exports.getCurrentStack = exports.changeErrorStackInPlace = exports.BufferedEvent = exports.LazySignal = void 0;
const immer_1 = __webpack_require__(6392);
__webpack_require__(9407);
(0, immer_1.enablePatches)();
// Export lazy signal first to avoid circular dependency issues
var LazySignal_1 = __webpack_require__(1322);
Object.defineProperty(exports, "LazySignal", ({ enumerable: true, get: function () { return LazySignal_1.LazySignal; } }));
var BufferedEvent_1 = __webpack_require__(4347);
Object.defineProperty(exports, "BufferedEvent", ({ enumerable: true, get: function () { return BufferedEvent_1.BufferedEvent; } }));
var errorStack_1 = __webpack_require__(2130);
Object.defineProperty(exports, "changeErrorStackInPlace", ({ enumerable: true, get: function () { return errorStack_1.changeErrorStackInPlace; } }));
Object.defineProperty(exports, "getCurrentStack", ({ enumerable: true, get: function () { return errorStack_1.getCurrentStack; } }));
var Event_1 = __webpack_require__(2926);
Object.defineProperty(exports, "Event", ({ enumerable: true, get: function () { return Event_1.Event; } }));
var lmsDefaultPorts_1 = __webpack_require__(8393);
Object.defineProperty(exports, "lmsDefaultPorts", ({ enumerable: true, get: function () { return lmsDefaultPorts_1.lmsDefaultPorts; } }));
var makePrettyError_1 = __webpack_require__(7578);
Object.defineProperty(exports, "makePrettyError", ({ enumerable: true, get: function () { return makePrettyError_1.makePrettyError; } }));
Object.defineProperty(exports, "makeTitledPrettyError", ({ enumerable: true, get: function () { return makePrettyError_1.makeTitledPrettyError; } }));
var makePromise_1 = __webpack_require__(1245);
Object.defineProperty(exports, "makePromise", ({ enumerable: true, get: function () { return makePromise_1.makePromise; } }));
var removeUndefinedValues_1 = __webpack_require__(5964);
Object.defineProperty(exports, "removeUndefinedValues", ({ enumerable: true, get: function () { return removeUndefinedValues_1.removeUndefinedValues; } }));
var resultTypes_1 = __webpack_require__(1956);
Object.defineProperty(exports, "createResultSchema", ({ enumerable: true, get: function () { return resultTypes_1.createResultSchema; } }));
Object.defineProperty(exports, "maybeErroredSchema", ({ enumerable: true, get: function () { return resultTypes_1.maybeErroredSchema; } }));
Object.defineProperty(exports, "promiseToMaybeErrored", ({ enumerable: true, get: function () { return resultTypes_1.promiseToMaybeErrored; } }));
Object.defineProperty(exports, "promiseToResult", ({ enumerable: true, get: function () { return resultTypes_1.promiseToResult; } }));
Object.defineProperty(exports, "unwrapPromiseOfMaybeErrored", ({ enumerable: true, get: function () { return resultTypes_1.unwrapPromiseOfMaybeErrored; } }));
Object.defineProperty(exports, "unwrapPromiseOfResult", ({ enumerable: true, get: function () { return resultTypes_1.unwrapPromiseOfResult; } }));
var runOnDispose_1 = __webpack_require__(7485);
Object.defineProperty(exports, "runOnDispose", ({ enumerable: true, get: function () { return runOnDispose_1.runOnDispose; } }));
var Signal_1 = __webpack_require__(9484);
Object.defineProperty(exports, "Signal", ({ enumerable: true, get: function () { return Signal_1.Signal; } }));
var SimpleLogger_1 = __webpack_require__(7830);
Object.defineProperty(exports, "SimpleLogger", ({ enumerable: true, get: function () { return SimpleLogger_1.SimpleLogger; } }));
var StreamablePromise_1 = __webpack_require__(3935);
Object.defineProperty(exports, "StreamablePromise", ({ enumerable: true, get: function () { return StreamablePromise_1.StreamablePromise; } }));
var text_1 = __webpack_require__(7087);
Object.defineProperty(exports, "text", ({ enumerable: true, get: function () { return text_1.text; } }));
var TimeoutTracker_1 = __webpack_require__(4013);
Object.defineProperty(exports, "TimeoutTracker", ({ enumerable: true, get: function () { return TimeoutTracker_1.TimeoutTracker; } }));
var toJSONSafeNumber_1 = __webpack_require__(9891);
Object.defineProperty(exports, "toJSONSafeNumber", ({ enumerable: true, get: function () { return toJSONSafeNumber_1.toJSONSafeNumber; } }));
var Validator_1 = __webpack_require__(3496);
Object.defineProperty(exports, "Validator", ({ enumerable: true, get: function () { return Validator_1.Validator; } }));
var WaitQueue_1 = __webpack_require__(8162);
Object.defineProperty(exports, "PagerExitedError", ({ enumerable: true, get: function () { return WaitQueue_1.PagerExitedError; } }));
Object.defineProperty(exports, "QueueClearedError", ({ enumerable: true, get: function () { return WaitQueue_1.QueueClearedError; } }));
Object.defineProperty(exports, "WaitQueue", ({ enumerable: true, get: function () { return WaitQueue_1.WaitQueue; } }));
var zodHelpers_1 = __webpack_require__(9662);
Object.defineProperty(exports, "failOk", ({ enumerable: true, get: function () { return zodHelpers_1.failOk; } }));
Object.defineProperty(exports, "filteredArray", ({ enumerable: true, get: function () { return zodHelpers_1.filteredArray; } }));
//

/***/ }),

/***/ 8393:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lmsDefaultPorts = void 0;
exports.lmsDefaultPorts = [1234];
//

/***/ }),

/***/ 7578:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makePrettyError = exports.makeTitledPrettyError = void 0;
const boxen_1 = __importDefault(__webpack_require__(9272));
const chalk_1 = __importDefault(__webpack_require__(8033));
const process_1 = __importDefault(__webpack_require__(9771));
const errorStack_1 = __webpack_require__(2130);
function makeTitledPrettyError(title, content, stack) {
    return makePrettyError(chalk_1.default.bgRed.white(` ${title} `) + "\n\n" + content, stack);
}
exports.makeTitledPrettyError = makeTitledPrettyError;
function makePrettyError(content, stack) {
    if (process_1.default.browser || process_1.default.env.LMS_NO_FANCY_ERRORS) {
        const error = new Error(content);
        if (stack === undefined) {
            (0, errorStack_1.changeErrorStackInPlace)(error, "");
        }
        else {
            (0, errorStack_1.changeErrorStackInPlace)(error, stack);
        }
        return error;
    }
    else {
        if (stack !== undefined) {
            content +=
                "\n\n\n " + chalk_1.default.bgWhite.black("  </> STACK TRACE  ") + "\n\n" + chalk_1.default.gray(stack);
        }
        const error = new Error("\n" + (0, boxen_1.default)(content, { padding: 1, margin: 1, borderColor: "redBright", title: "Error" }));
        (0, errorStack_1.changeErrorStackInPlace)(error, "");
        return error;
    }
}
exports.makePrettyError = makePrettyError;
//

/***/ }),

/***/ 1245:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makePromise = void 0;
function makePromise() {
    let resolve;
    let reject;
    const promise = new Promise((_resolve, _reject) => {
        resolve = _resolve;
        reject = _reject;
    });
    return { promise, resolve: resolve, reject: reject };
}
exports.makePromise = makePromise;
//

/***/ }),

/***/ 9407:
/***/ (() => {

"use strict";

// Extremely lightweight polyfill for Symbol.dispose and Symbol.asyncDispose
if (typeof Symbol.dispose !== "symbol") {
    Object.defineProperty(Symbol, "dispose", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Symbol.for("dispose"),
    });
}
if (typeof Symbol.asyncDispose !== "symbol") {
    Object.defineProperty(Symbol, "asyncDispose", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: Symbol.for("asyncDispose"),
    });
}
//

/***/ }),

/***/ 5964:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeUndefinedValues = void 0;
/**
 * Removes properties with `undefined` values from an object.
 *
 * This function can be useful in scenarios where you want to ensure that an object does not contain
 * any `undefined` values. For example, when the resulting value is used to overwrite some default
 * values.
 *
 * Note: This function does not mutate the original object. It returns a new object that does not
 * include the `undefined` values.
 *
 * @param obj - The object from which to remove `undefined` values.
 * @returns A new object that does not include the `undefined` values.
 * @example
 * ```typescript
 * const obj = { a: 1, b: undefined, c: 'test' };
 * const result = removeUndefinedValues(obj);
 * console.log(result); // { a: 1, c: 'test' }
 * ```
 */
function removeUndefinedValues(obj) {
    return Object.fromEntries(Object.entries(obj).filter(([_, v]) => v !== undefined));
}
exports.removeUndefinedValues = removeUndefinedValues;
//

/***/ }),

/***/ 1956:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unwrapPromiseOfResult = exports.promiseToResult = exports.createResultSchema = exports.unwrapPromiseOfMaybeErrored = exports.promiseToMaybeErrored = exports.maybeErroredSchema = void 0;
const lms_shared_types_1 = __webpack_require__(5790);
const zod_1 = __webpack_require__(6851);
exports.maybeErroredSchema = zod_1.z.discriminatedUnion("success", [
    zod_1.z.object({
        success: zod_1.z.literal(true),
    }),
    zod_1.z.object({
        success: zod_1.z.literal(false),
        error: lms_shared_types_1.serializedLMSExtendedErrorSchema,
    }),
]);
function promiseToMaybeErrored(promise) {
    return promise.then(() => ({ success: true }), error => ({ success: false, error: (0, lms_shared_types_1.serializeError)(error) }));
}
exports.promiseToMaybeErrored = promiseToMaybeErrored;
async function unwrapPromiseOfMaybeErrored(promise) {
    const result = await promise;
    if (result.success) {
        return Promise.resolve();
    }
    else {
        return Promise.reject((0, lms_shared_types_1.fromSerializedError)(result.error));
    }
}
exports.unwrapPromiseOfMaybeErrored = unwrapPromiseOfMaybeErrored;
function createResultSchema(schema) {
    return zod_1.z.discriminatedUnion("success", [
        zod_1.z.object({
            success: zod_1.z.literal(true),
            result: schema,
        }),
        zod_1.z.object({
            success: zod_1.z.literal(false),
            error: lms_shared_types_1.serializedLMSExtendedErrorSchema,
        }),
    ]);
}
exports.createResultSchema = createResultSchema;
function promiseToResult(promise) {
    return promise.then(result => ({ success: true, result }), error => ({ success: false, error: (0, lms_shared_types_1.serializeError)(error) }));
}
exports.promiseToResult = promiseToResult;
async function unwrapPromiseOfResult(promise) {
    const result = await promise;
    if (result.success) {
        return result.result;
    }
    else {
        return Promise.reject((0, lms_shared_types_1.fromSerializedError)(result.error));
    }
}
exports.unwrapPromiseOfResult = unwrapPromiseOfResult;
//

/***/ }),

/***/ 7485:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runOnDispose = void 0;
function runOnDispose(fn) {
    return {
        [Symbol.dispose]: fn,
    };
}
exports.runOnDispose = runOnDispose;
//

/***/ }),

/***/ 7087:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.text = void 0;
/**
 * A cache for avoiding recompiling the same template strings.
 *
 * The cached value is a string with 2N + 1 elements, where N is the number of variables in the
 * template.
 */
const compiledTemplatesCache = new WeakMap();
/**
 * A string literal tag function that does the following:
 *
 * - Removes leading new lines
 * - Removes trailing new lines and whitespace
 * - Removes common indentation from the start of each line (Empty lines are ignored)
 * - Single newlines are replaced with a space + extra whitespace is removed
 *
 * Note: Only spaces are considered.
 */
function text(strings, ...values) {
    if (values.length + 1 !== strings.length) {
        throw new Error("text called with the wrong number of arguments.");
    }
    let compiled = compiledTemplatesCache.get(strings);
    if (compiled === undefined) {
        compiled = compile(strings);
        compiledTemplatesCache.set(strings, compiled);
    }
    // We can modify the array in place because JavaScript is single-threaded and the array is not
    // being accessed by any other code.
    for (let i = 0; i < values.length; i++) {
        if (typeof values[i] === "object") {
            try {
                compiled[i * 2 + 1] = JSON.stringify(values[i]);
            }
            catch (error) {
                compiled[i * 2 + 1] = "[Object failed to stringify]";
            }
        }
        else {
            compiled[i * 2 + 1] = String(values[i]);
        }
    }
    return compiled.join("");
}
exports.text = text;
function removeLeadingNewlines(input) {
    return input.replace(/^\n+/, "");
}
function removeTrailingNewlinesAndWhitespace(input) {
    return input.replace(/[\n ]+$/, "");
}
function removeLeadingWhitespace(input) {
    return input.replace(/^ +/, "");
}
function removeTrailingWhitespace(input) {
    return input.replace(/ +$/, "");
}
function breakIntoLines(strings) {
    const lines = [];
    let currentLine = [];
    for (const string of strings) {
        let prevNewlineIndex = -1;
        let nextNewlineIndex;
        while ((nextNewlineIndex = string.indexOf("\n", prevNewlineIndex + 1)) !== -1) {
            currentLine.push(string.substring(prevNewlineIndex + 1, nextNewlineIndex));
            lines.push(currentLine);
            currentLine = [];
            prevNewlineIndex = nextNewlineIndex;
        }
        currentLine.push(string.substring(prevNewlineIndex + 1));
    }
    lines.push(currentLine);
    return lines;
}
/**
 * Returns the number of spaces at the start of the string. If the string only contains spaces,
 * returns infinity.
 */
function countStringIndentations(string) {
    let count = 0;
    for (const char of string) {
        if (char === " ") {
            count++;
        }
        else {
            return count;
        }
    }
    return Infinity;
}
function countLineIndentations(line) {
    const firstPart = line[0];
    const firstPartIndentation = countStringIndentations(firstPart);
    if (firstPartIndentation === Infinity) {
        if (line.length === 1) {
            return Infinity;
        }
        else {
            // If there is a variable after it, the length of indentation is the same as the length of the
            // first part.
            return firstPart.length;
        }
    }
    return firstPartIndentation;
}
function findMaxCommonIndentation(lines) {
    let minIndentation = Infinity;
    for (const line of lines) {
        minIndentation = Math.min(minIndentation, countLineIndentations(line));
    }
    return minIndentation;
}
function removeIndentation(line, indentation) {
    if (line.length < indentation) {
        return "";
    }
    return line.slice(indentation);
}
function removeAllIndentation(lines, indentation) {
    for (const line of lines) {
        line[0] = removeIndentation(line[0], indentation);
    }
}
function isEmptyLine(line) {
    if (line.length !== 1) {
        return false;
    }
    for (const char of line[0]) {
        if (char !== " ") {
            return false;
        }
    }
    return true;
}
function mergeLines(lines) {
    const linesAreEmpty = lines.map(isEmptyLine);
    const paragraphs = [];
    let currentParagraph = [];
    for (let i = 0; i < lines.length; i++) {
        if (linesAreEmpty[i]) {
            if (currentParagraph.length !== 0) {
                paragraphs.push(currentParagraph);
                currentParagraph = [];
            }
            continue;
        }
        if (currentParagraph.length !== 0) {
            const last = removeTrailingWhitespace(currentParagraph[currentParagraph.length - 1]);
            const next = removeLeadingWhitespace(lines[i][0]);
            currentParagraph[currentParagraph.length - 1] = last + " " + next;
            currentParagraph.push(...lines[i].slice(1));
        }
        else {
            currentParagraph.push(...lines[i]);
        }
    }
    if (currentParagraph.length !== 0) {
        paragraphs.push(currentParagraph);
    }
    return paragraphs;
}
function mergeParagraphs(paragraphs) {
    const result = [];
    if (paragraphs.length === 0) {
        return [""];
    }
    result.push(...paragraphs[0]);
    for (let i = 1; i < paragraphs.length; i++) {
        result[result.length - 1] += "\n\n" + paragraphs[i][0];
        result.push(...paragraphs[i].slice(1));
    }
    return result;
}
function addHolesForVariables(strings) {
    const result = [];
    for (let i = 0; i < strings.length; i++) {
        result.push(strings[i]);
        if (i < strings.length - 1) {
            result.push("");
        }
    }
    return result;
}
function compile(readonlyStrings) {
    const strings = [...readonlyStrings];
    strings[0] = removeLeadingNewlines(strings[0]);
    strings[strings.length - 1] = removeTrailingNewlinesAndWhitespace(strings[strings.length - 1]);
    const lines = breakIntoLines(strings);
    const commonIndentation = findMaxCommonIndentation(lines);
    removeAllIndentation(lines, commonIndentation);
    const paragraphs = mergeLines(lines);
    return addHolesForVariables(mergeParagraphs(paragraphs));
}
//

/***/ }),

/***/ 9891:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toJSONSafeNumber = void 0;
function toJSONSafeNumber(value) {
    if (!Number.isFinite(value)) {
        return undefined;
    }
    else if (Number.isNaN(value)) {
        return undefined;
    }
    else {
        return value;
    }
}
exports.toJSONSafeNumber = toJSONSafeNumber;
//

/***/ }),

/***/ 9662:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.failOk = exports.filteredArray = void 0;
const zod_1 = __webpack_require__(6851);
/**
 * Makes a Zod schema that filters out elements that do not match the provided schema.
 */
function filteredArray(schema) {
    return zod_1.z.array(zod_1.z.any()).transform(val => val
        .map(v => schema.safeParse(v))
        .filter(parsed => parsed.success)
        .map(parsed => parsed.data));
}
exports.filteredArray = filteredArray;
/**
 * Makes a Zod schema that turns a failed parse into an `undefined`.
 */
function failOk(schema) {
    return zod_1.z.any().transform(val => {
        const parsed = schema.safeParse(val);
        if (parsed.success) {
            return parsed.data;
        }
        return undefined;
    });
}
exports.failOk = failOk;
//

/***/ }),

/***/ 9602:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthenticatedWsClientTransport = void 0;
const WsAuthenticationResult_1 = __webpack_require__(7418);
const WsClientTransport_1 = __webpack_require__(7127);
class AuthenticatedWsClientTransport extends WsClientTransport_1.WsClientTransport {
    constructor(url, clientIdentifier, clientPasskey, receivedMessage, errored, parentLogger) {
        super(url, receivedMessage, errored, parentLogger);
        this.clientIdentifier = clientIdentifier;
        this.clientPasskey = clientPasskey;
        this.logger = this.logger.subclass("AuthenticatedWsClientTransport");
    }
    static createAuthenticatedWsClientTransportFactory({ url, clientIdentifier, clientPasskey, }) {
        return (receivedMessage, errored, parentLogger) => new AuthenticatedWsClientTransport(url, clientIdentifier, clientPasskey, receivedMessage, errored, parentLogger);
    }
    onWsOpen() {
        this.ws.send(JSON.stringify({
            authVersion: 1,
            clientIdentifier: this.clientIdentifier,
            clientPasskey: this.clientPasskey,
        }));
        this.ws.addEventListener("message", (event) => {
            try {
                const data = JSON.parse(event.data.toString("utf-8"));
                const result = WsAuthenticationResult_1.wsAuthenticationResultSchema.parse(data);
                if (result.success) {
                    super.onWsOpen();
                }
                else {
                    this.onWsError(new Error("Failed to authenticate: " + result.error));
                }
            }
            catch (error) {
                this.onWsError(new Error("Failed to parse authentication result: " + error?.message));
            }
        }, {
            once: true,
        });
    }
}
exports.AuthenticatedWsClientTransport = AuthenticatedWsClientTransport;
//

/***/ }),

/***/ 1973:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientPort = void 0;
const lms_common_1 = __webpack_require__(2934);
const lms_communication_1 = __webpack_require__(5305);
const lms_shared_types_1 = __webpack_require__(5790);
function defaultErrorDeserializer(serialized, stack) {
    const error = (0, lms_shared_types_1.fromSerializedError)(serialized);
    if (stack === undefined) {
        (0, lms_common_1.changeErrorStackInPlace)(error, "");
    }
    else {
        (0, lms_common_1.changeErrorStackInPlace)(error, stack);
    }
    return error;
}
class ClientPort {
    constructor(backendInterface, factory, { parentLogger, errorDeserializer, verboseErrorMessage, } = {}) {
        this.backendInterface = backendInterface;
        this.openChannels = new Map();
        this.ongoingRpcs = new Map();
        this.openCommunicationsCount = 0;
        this.nextChannelId = 0;
        this.producedCommunicationWarningsCount = 0;
        this.receivedMessage = (message) => {
            switch (message.type) {
                case "channelSend": {
                    this.receivedChannelSend(message);
                    break;
                }
                case "channelAck": {
                    this.receivedChannelAck(message);
                    break;
                }
                case "channelClose": {
                    this.receivedChannelClose(message);
                    break;
                }
                case "channelError": {
                    this.receivedChannelError(message);
                    break;
                }
                case "rpcResult": {
                    this.receivedRpcResult(message);
                    break;
                }
                case "rpcError": {
                    this.receivedRpcError(message);
                    break;
                }
                case "communicationWarning": {
                    this.receivedCommunicationWarning(message);
                    break;
                }
                case "keepAliveAck": {
                    this.receivedKeepAliveAck(message);
                    break;
                }
            }
        };
        this.errored = (error) => {
            for (const openChannel of this.openChannels.values()) {
                openChannel.errored(error);
            }
            for (const ongoingRpc of this.ongoingRpcs.values()) {
                ongoingRpc.reject(error);
            }
        };
        this.logger = new lms_common_1.SimpleLogger("ClientPort", parentLogger);
        this.errorDeserializer = errorDeserializer ?? defaultErrorDeserializer;
        this.verboseErrorMessage = verboseErrorMessage ?? false;
        this.transport = factory(this.receivedMessage, this.errored, this.logger);
    }
    communicationWarning(warning) {
        if (this.producedCommunicationWarningsCount >= 5) {
            return;
        }
        this.logger.warnText `
      Produced communication warning: ${warning}
      
      This is usually caused by communication protocol incompatibility. Please make sure you are
      using the up-to-date versions of the SDK and LM Studio.
    `;
        this.transport.send({
            type: "communicationWarning",
            warning,
        });
        this.producedCommunicationWarningsCount++;
        if (this.producedCommunicationWarningsCount >= 5) {
            this.logger.errorText `
        5 communication warnings have been produced. Further warnings will not be printed.
      `;
        }
    }
    updateOpenCommunicationsCount() {
        const previousCount = this.openCommunicationsCount;
        this.openCommunicationsCount = this.openChannels.size + this.ongoingRpcs.size;
        if (this.openCommunicationsCount === 0 && previousCount > 0) {
            this.transport.onHavingNoOpenCommunication();
        }
        else if (this.openCommunicationsCount === 1 && previousCount === 0) {
            this.transport.onHavingOneOrMoreOpenCommunication();
        }
    }
    receivedChannelSend(message) {
        const openChannel = this.openChannels.get(message.channelId);
        if (openChannel === undefined) {
            this.communicationWarning(`Received channelSend for unknown channel, channelId = ${message.channelId}`);
            return;
        }
        const parsed = openChannel.endpoint.toClientPacket.safeParse(message.message);
        if (!parsed.success) {
            this.communicationWarning((0, lms_common_1.text) `
        Received invalid message for channel: endpointName = ${openChannel.endpoint.name}, message =
        ${message.message}. Zod error:

        ${lms_common_1.Validator.prettyPrintZod("message", parsed.error)}
      `);
            return;
        }
        openChannel.receivedMessage(parsed.data);
    }
    receivedChannelAck(message) {
        const openChannel = this.openChannels.get(message.channelId);
        if (openChannel === undefined) {
            this.communicationWarning(`Received channelAck for unknown channel, channelId = ${message.channelId}`);
            return;
        }
        openChannel.receivedAck(message.ackId);
    }
    receivedChannelClose(message) {
        const openChannel = this.openChannels.get(message.channelId);
        if (openChannel === undefined) {
            this.communicationWarning(`Received channelClose for unknown channel, channelId = ${message.channelId}`);
            return;
        }
        this.openChannels.delete(message.channelId);
        openChannel.closed();
        this.updateOpenCommunicationsCount();
    }
    receivedChannelError(message) {
        const openChannel = this.openChannels.get(message.channelId);
        if (openChannel === undefined) {
            this.communicationWarning(`Received channelError for unknown channel, channelId = ${message.channelId}`);
            return;
        }
        this.openChannels.delete(message.channelId);
        const error = this.errorDeserializer(message.error, this.verboseErrorMessage ? openChannel.stack : undefined);
        openChannel.errored(error);
        this.updateOpenCommunicationsCount();
    }
    receivedRpcResult(message) {
        const ongoingRpc = this.ongoingRpcs.get(message.callId);
        if (ongoingRpc === undefined) {
            this.communicationWarning(`Received rpcResult for unknown rpc, callId = ${message.callId}`);
            return;
        }
        const parsed = ongoingRpc.endpoint.returns.safeParse(message.result);
        if (!parsed.success) {
            this.communicationWarning((0, lms_common_1.text) `
        Received invalid result for rpc, endpointName = ${ongoingRpc.endpoint.name}, result =
        ${message.result}. Zod error:

        ${lms_common_1.Validator.prettyPrintZod("result", parsed.error)}
      `);
            return;
        }
        ongoingRpc.resolve(parsed.data);
        this.ongoingRpcs.delete(message.callId);
        this.updateOpenCommunicationsCount();
    }
    receivedRpcError(message) {
        const ongoingRpc = this.ongoingRpcs.get(message.callId);
        if (ongoingRpc === undefined) {
            this.communicationWarning(`Received rpcError for unknown rpc, callId = ${message.callId}`);
            return;
        }
        const error = this.errorDeserializer(message.error, this.verboseErrorMessage ? ongoingRpc.stack : undefined);
        ongoingRpc.reject(error);
        this.ongoingRpcs.delete(message.callId);
        this.updateOpenCommunicationsCount();
    }
    receivedCommunicationWarning(message) {
        this.logger.warnText `
      Received communication warning from the server: ${message.warning}
      
      This is usually caused by communication protocol incompatibility. Please make sure you are
      using the up-to-date versions of the SDK and LM Studio.

      Note: This warning was received from the server and is printed on the client for convenience.
    `;
    }
    receivedKeepAliveAck(_message) {
        // Do nothing
    }
    async callRpc(endpointName, param, { stack } = {}) {
        const endpoint = this.backendInterface.getRpcEndpoint(endpointName);
        if (endpoint === undefined) {
            throw new Error(`No Rpc endpoint with name ${endpointName}`);
        }
        const parameter = endpoint.parameter.parse(param);
        const callId = this.nextChannelId;
        this.nextChannelId++;
        const { promise, resolve, reject } = (0, lms_common_1.makePromise)();
        stack = stack ?? (0, lms_common_1.getCurrentStack)(1);
        this.ongoingRpcs.set(callId, {
            endpoint,
            stack,
            resolve,
            reject,
        });
        this.transport.send({
            type: "rpcCall",
            endpoint: endpointName,
            callId,
            parameter,
        });
        this.updateOpenCommunicationsCount();
        return await promise;
    }
    createChannel(endpointName, param, onMessage, { stack } = {}) {
        const channelEndpoint = this.backendInterface.getChannelEndpoint(endpointName);
        if (channelEndpoint === undefined) {
            throw new Error(`No channel endpoint with name ${endpointName}`);
        }
        const creationParameter = channelEndpoint.creationParameter.parse(param);
        const channelId = this.nextChannelId;
        this.nextChannelId++;
        this.transport.send({
            type: "channelCreate",
            endpoint: endpointName,
            channelId,
            creationParameter,
        });
        stack = stack ?? (0, lms_common_1.getCurrentStack)(1);
        const openChannel = {
            endpoint: channelEndpoint,
            stack,
            ...lms_communication_1.Channel.create(packet => {
                const result = channelEndpoint.toServerPacket.parse(packet);
                this.transport.send({
                    type: "channelSend",
                    channelId,
                    message: result,
                });
            }),
        };
        if (onMessage !== undefined) {
            openChannel.channel.onMessage.subscribe(onMessage);
        }
        this.openChannels.set(channelId, openChannel);
        this.updateOpenCommunicationsCount();
        return openChannel.channel;
    }
}
exports.ClientPort = ClientPort;
//

/***/ }),

/***/ 5266:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenericClientTransport = void 0;
const lms_common_1 = __webpack_require__(2934);
const lms_communication_1 = __webpack_require__(5305);
class GenericClientTransport extends lms_communication_1.ClientTransport {
    constructor(onMessage, onClose, sendMessage, receivedMessage, errored, parentLogger) {
        super();
        this.sendMessage = sendMessage;
        this.receivedMessage = receivedMessage;
        this.errored = errored;
        this.closed = false;
        this.logger = new lms_common_1.SimpleLogger("GenericClientTransport", parentLogger);
        onMessage.subscribe(message => {
            let parsed;
            try {
                parsed = this.parseIncomingMessage(message);
            }
            catch (error) {
                this.logger.warn("Received invalid message from server:", message);
                return;
            }
            this.receivedMessage(parsed);
        });
        onClose.subscribeOnce(() => {
            if (this.closed) {
                return;
            }
            this.closed = true;
            this.errored(new Error("Server closed the connection"));
        });
    }
    static createFactory(onMessage, onClose, sendMessage) {
        return (receivedMessage, errored, parentLogger) => new GenericClientTransport(onMessage, onClose, sendMessage, receivedMessage, errored, parentLogger);
    }
    sendViaTransport(message) {
        this.sendMessage(message);
    }
}
exports.GenericClientTransport = GenericClientTransport;
//

/***/ }),

/***/ 7127:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WsClientTransport = void 0;
const lms_common_1 = __webpack_require__(2934);
const lms_communication_1 = __webpack_require__(5305);
const lms_isomorphic_1 = __webpack_require__(390);
var WsClientTransportStatus;
(function (WsClientTransportStatus) {
    WsClientTransportStatus["Disconnected"] = "DISCONNECTED";
    WsClientTransportStatus["Connecting"] = "CONNECTING";
    WsClientTransportStatus["Connected"] = "CONNECTED";
})(WsClientTransportStatus || (WsClientTransportStatus = {}));
class WsClientTransport extends lms_communication_1.ClientTransport {
    constructor(url, receivedMessage, errored, parentLogger) {
        super();
        this.url = url;
        this.receivedMessage = receivedMessage;
        this.errored = errored;
        this.ws = null;
        this.queuedMessages = [];
        this.status = WsClientTransportStatus.Disconnected;
        this.resolvedUrl = null;
        /**
         * Whether the underlying socket should hold the process open.
         */
        this.shouldRef = false;
        this.logger = new lms_common_1.SimpleLogger("WsClientTransport", parentLogger);
    }
    static createWsClientTransportFactory(url) {
        return (receivedMessage, errored, parentLogger) => new WsClientTransport(url, receivedMessage, errored, parentLogger);
    }
    connect() {
        if (this.status !== WsClientTransportStatus.Disconnected) {
            this.logger.warn("connect() called while not disconnected");
            return;
        }
        this.status = WsClientTransportStatus.Connecting;
        Promise.resolve(this.url).then(url => {
            this.resolvedUrl = url;
            this.ws = new lms_isomorphic_1.WebSocket(url);
            this.ws.addEventListener("open", this.onWsOpen.bind(this));
            this.ws.addEventListener("error", this.onWsError.bind(this));
        });
    }
    // private timeOut
    // private setupWebsocketKeepAlive(ws: WebSocket, onTimeout: () => void) {
    //   const socket = (ws as any)._socket as Socket | null | undefined;
    //   if (socket) {
    //     // Exists, use node.js methods
    //     socket.setKeepAlive(true, KEEP_ALIVE_INTERVAL);
    //     socket.setTimeout(KEEP_ALIVE_TIMEOUT, onTimeout);
    //   } else {
    //   }
    // }
    onWsOpen() {
        this.ws.addEventListener("message", this.onWsMessage.bind(this));
        this.status = WsClientTransportStatus.Connected;
        this.queuedMessages.forEach(message => this.sendViaTransport(message));
        this.queuedMessages = [];
        this.updateShouldRef(this.shouldRef);
        // this.setupWebsocketKeepAlive(this.ws!, this.onWsTimeout.bind(this));
    }
    onWsMessage(event) {
        if (this.status !== WsClientTransportStatus.Connected) {
            this.logger.warn("Received message while not connected. Message ignored:", event.data);
            return;
        }
        let message;
        try {
            message = JSON.parse(String(event.data));
        }
        catch (error) {
            this.logger.warn("Received invalid JSON message from server:", event.data);
            return;
        }
        let parsed;
        try {
            parsed = this.parseIncomingMessage(message);
        }
        catch (error) {
            this.logger.warn("Received invalid message from server:", message);
            return;
        }
        this.receivedMessage(parsed);
    }
    onWsError(event) {
        if (this.status === WsClientTransportStatus.Disconnected) {
            return;
        }
        this.logger.warn("WebSocket error:", event.error);
        if (event.error.code === "ECONNREFUSED") {
            this.logger.warnText `
          WebSocket connection refused. This can happen if the server is not running or the client
          is trying to connect to the wrong path. The server path that this client is
          attempting to connect to is:
          ${this.resolvedUrl ?? "Unknown" /* Should never be Unknown */}.

          Please make sure the following:

            1. LM Studio is running

            2. The API server in LM Studio has started

            3. The client is attempting to connect to the correct path
        `;
        }
        try {
            this.ws?.close();
        }
        catch (error) {
            // Ignore
        }
        this.status = WsClientTransportStatus.Disconnected;
        this.errored(event);
    }
    onWsTimeout() {
        if (this.status === WsClientTransportStatus.Disconnected) {
            return;
        }
        this.logger.warn("Websocket timed out");
        try {
            this.ws?.close();
        }
        catch (error) {
            // Ignore
        }
        this.status = WsClientTransportStatus.Disconnected;
        this.errored(new Error("WebSocket timed out"));
    }
    onHavingNoOpenCommunication() {
        this.updateShouldRef(false);
    }
    onHavingOneOrMoreOpenCommunication() {
        this.updateShouldRef(true);
    }
    updateShouldRef(shouldRef) {
        this.shouldRef = shouldRef;
        if (this.ws === null) {
            return;
        }
        if (!this.ws._socket) {
            return;
        }
        if (shouldRef) {
            this.ws._socket.ref();
        }
        else {
            this.ws._socket.unref();
        }
    }
    sendViaTransport(message) {
        if (this.status === WsClientTransportStatus.Connected) {
            this.ws.send(JSON.stringify(message));
        }
        else {
            this.queuedMessages.push(message);
            if (this.status === WsClientTransportStatus.Disconnected) {
                this.connect();
            }
        }
    }
}
exports.WsClientTransport = WsClientTransport;
//

/***/ }),

/***/ 3697:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WsClientTransport = exports.GenericClientTransport = exports.ClientPort = exports.AuthenticatedWsClientTransport = void 0;
var AuthenticatedWsClientTransport_1 = __webpack_require__(9602);
Object.defineProperty(exports, "AuthenticatedWsClientTransport", ({ enumerable: true, get: function () { return AuthenticatedWsClientTransport_1.AuthenticatedWsClientTransport; } }));
var ClientPort_1 = __webpack_require__(1973);
Object.defineProperty(exports, "ClientPort", ({ enumerable: true, get: function () { return ClientPort_1.ClientPort; } }));
var GenericClientTransport_1 = __webpack_require__(5266);
Object.defineProperty(exports, "GenericClientTransport", ({ enumerable: true, get: function () { return GenericClientTransport_1.GenericClientTransport; } }));
var WsClientTransport_1 = __webpack_require__(7127);
Object.defineProperty(exports, "WsClientTransport", ({ enumerable: true, get: function () { return WsClientTransport_1.WsClientTransport; } }));
//

/***/ }),

/***/ 7158:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BackendInterface = void 0;
/* eslint-disable @typescript-eslint/ban-types */
const zod_1 = __webpack_require__(6851);
class BackendInterface {
    constructor() {
        this.unhandledEndpoints = new Set();
        this.existingEndpointNames = new Set();
        this.rpcEndpoints = new Map();
        this.channelEndpoints = new Map();
    }
    withContextType() {
        return this;
    }
    assertEndpointNameNotExists(endpointName) {
        if (this.existingEndpointNames.has(endpointName)) {
            throw new Error(`Endpoint with name ${endpointName} already exists`);
        }
    }
    /**
     * Register an Rpc endpoint.
     */
    addRpcEndpoint(endpointName, { parameter, returns, }) {
        this.assertEndpointNameNotExists(endpointName);
        this.existingEndpointNames.add(endpointName);
        this.rpcEndpoints.set(endpointName, {
            name: endpointName,
            parameter,
            returns,
            handler: null,
        });
        return this;
    }
    addChannelEndpoint(endpointName, { creationParameter, toServerPacket, toClientPacket, }) {
        this.assertEndpointNameNotExists(endpointName);
        this.existingEndpointNames.add(endpointName);
        this.channelEndpoints.set(endpointName, {
            name: endpointName,
            creationParameter,
            toServerPacket,
            toClientPacket,
            handler: null,
        });
        return this;
    }
    addSignalEndpoint(endpointName, { creationParameter, signalData, }) {
        return this.addChannelEndpoint(endpointName, {
            creationParameter,
            toServerPacket: zod_1.z.undefined(),
            toClientPacket: signalData,
        });
    }
    /**
     * Adds a handler for an Rpc endpoint.
     */
    handleRpcEndpoint(endpointName, handler) {
        const endpoint = this.rpcEndpoints.get(endpointName);
        if (endpoint === undefined) {
            throw new Error(`No Rpc endpoint with name ${endpointName}`);
        }
        if (endpoint.handler !== null) {
            throw new Error(`Rpc endpoint with name ${endpointName} already has a handler`);
        }
        endpoint.handler = handler;
        this.unhandledEndpoints.delete(endpointName);
    }
    /**
     * Adds a handler for a channel endpoint.
     */
    handleChannelEndpoint(endpointName, handler) {
        const endpoint = this.channelEndpoints.get(endpointName);
        if (endpoint === undefined) {
            throw new Error(`No channel endpoint with name ${endpointName}`);
        }
        if (endpoint.handler !== null) {
            throw new Error(`Channel endpoint with name ${endpointName} already has a handler`);
        }
        endpoint.handler = handler;
        this.unhandledEndpoints.delete(endpointName);
    }
    assertAllEndpointsHandled() {
        if (this.unhandledEndpoints.size > 0) {
            throw new Error(`The following endpoints were not handled: ${Array.from(this.unhandledEndpoints).join(", ")}`);
        }
    }
    getRpcEndpoint(endpointName) {
        return this.rpcEndpoints.get(endpointName);
    }
    getChannelEndpoint(endpointName) {
        return this.channelEndpoints.get(endpointName);
    }
}
exports.BackendInterface = BackendInterface;
//

/***/ }),

/***/ 3142:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Channel = exports.ConnectionStatus = void 0;
const lms_common_1 = __webpack_require__(2934);
var ConnectionStatus;
(function (ConnectionStatus) {
    /**
     * The underlying transport is connected and is communicating properly.
     */
    ConnectionStatus["Connected"] = "CONNECTED";
    /**
     * The underlying transport has errored out.
     */
    ConnectionStatus["Errored"] = "ERRORED";
    /**
     * The channel has been properly closed and no more messages will be sent or received.
     */
    ConnectionStatus["Closed"] = "CLOSED";
})(ConnectionStatus || (exports.ConnectionStatus = ConnectionStatus = {}));
const logger = new lms_common_1.SimpleLogger("Channel");
class Channel {
    constructor(innerSend) {
        this.innerSend = innerSend;
        this.nextAckId = 0;
        /**
         * A map for messages that are waiting for an ACK. The values are the functions to resolve or
         * reject the corresponding promise.
         */
        this.waitingForAck = new Map();
        /**
         * Returned as a part of create. It should be called by the controlling port.
         */
        this.receivedACK = (ackId) => {
            if (this.connectionStatus.get() !== ConnectionStatus.Connected) {
                logger.warn("Received ACK while in status", this.connectionStatus.get());
                return;
            }
            const waiting = this.waitingForAck.get(ackId);
            if (waiting === undefined) {
                logger.warn("Received ACK for a message that is no longer waiting for ACK, ackId =", ackId);
                return;
            }
            waiting.resolve();
        };
        /**
         * Returned as a part of create. It should be called by the controlling port.
         */
        this.receivedMessage = (packet) => {
            if (this.connectionStatus.get() !== ConnectionStatus.Connected) {
                logger.warn("Received message while in status", this.connectionStatus.get());
                return;
            }
            this.emitOnMessage(packet);
        };
        /**
         * Returned as a part of create. It should be called by the controlling port.
         */
        this.errored = (error) => {
            if (this.connectionStatus.get() !== ConnectionStatus.Connected) {
                logger.warn("Received error while in status", this.connectionStatus.get());
                return;
            }
            this.rejectAllWaitingForAck(error);
            this.setConnectionStatus(ConnectionStatus.Errored);
            this.emitOnError(error);
        };
        /**
         * Returned as a part of create. It should be called by the controlling port.
         */
        this.closed = () => {
            this.rejectAllWaitingForAck(new Error("Channel closed"));
            this.setConnectionStatus(ConnectionStatus.Closed);
            this.emitOnClose();
        };
        [this.onMessage, this.emitOnMessage] = lms_common_1.BufferedEvent.create();
        [this.onError, this.emitOnError] = lms_common_1.BufferedEvent.create();
        [this.onClose, this.emitOnClose] = lms_common_1.BufferedEvent.create();
        [this.connectionStatus, this.setConnectionStatus] = lms_common_1.Signal.create(ConnectionStatus.Connected);
    }
    rejectAllWaitingForAck(error) {
        const rejects = Array.from(this.waitingForAck.values()).map(({ reject }) => reject);
        this.waitingForAck.clear();
        for (const reject of rejects) {
            reject(error);
        }
    }
    static create(innerSend) {
        const channel = new Channel(innerSend);
        return {
            channel,
            receivedAck: channel.receivedACK,
            receivedMessage: channel.receivedMessage,
            errored: channel.errored,
            closed: channel.closed,
        };
    }
    send(packet) {
        this.innerSend(packet);
    }
    sendAndWaitForACK(packet) {
        const { promise, resolve, reject } = (0, lms_common_1.makePromise)();
        const ackId = this.nextAckId;
        this.nextAckId++;
        this.waitingForAck.set(ackId, { resolve, reject });
        this.innerSend(packet, ackId);
        return promise;
    }
}
exports.Channel = Channel;
//

/***/ }),

/***/ 5156:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServerTransport = exports.ClientTransport = exports.Transport = void 0;
const lms_shared_types_1 = __webpack_require__(5790);
const zod_1 = __webpack_require__(6851);
const clientToServerMessageSchema = zod_1.z.discriminatedUnion("type", [
    zod_1.z.object({
        type: zod_1.z.literal("channelCreate"),
        endpoint: zod_1.z.string(),
        channelId: zod_1.z.number(),
        creationParameter: zod_1.z.any(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("channelSend"),
        channelId: zod_1.z.number(),
        message: zod_1.z.any(),
        ackId: zod_1.z.number().optional(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("channelAck"),
        channelId: zod_1.z.number(),
        ackId: zod_1.z.number(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("rpcCall"),
        endpoint: zod_1.z.string(),
        callId: zod_1.z.number(),
        parameter: zod_1.z.any(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("communicationWarning"),
        warning: zod_1.z.string(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("keepAlive"),
    }),
]);
const serverToClientMessageSchema = zod_1.z.discriminatedUnion("type", [
    zod_1.z.object({
        type: zod_1.z.literal("channelSend"),
        channelId: zod_1.z.number(),
        message: zod_1.z.any(),
        ackId: zod_1.z.number().optional(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("channelAck"),
        channelId: zod_1.z.number(),
        ackId: zod_1.z.number(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("channelClose"),
        channelId: zod_1.z.number(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("channelError"),
        channelId: zod_1.z.number(),
        error: lms_shared_types_1.serializedLMSExtendedErrorSchema,
    }),
    zod_1.z.object({
        type: zod_1.z.literal("rpcResult"),
        callId: zod_1.z.number(),
        result: zod_1.z.any(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("rpcError"),
        callId: zod_1.z.number(),
        error: lms_shared_types_1.serializedLMSExtendedErrorSchema,
    }),
    zod_1.z.object({
        type: zod_1.z.literal("communicationWarning"),
        warning: zod_1.z.string(),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("keepAliveAck"),
    }),
]);
class Transport {
}
exports.Transport = Transport;
class ClientTransport extends Transport {
    parseIncomingMessage(message) {
        return serverToClientMessageSchema.parse(message);
    }
    send(message) {
        const result = clientToServerMessageSchema.parse(message);
        this.sendViaTransport(result);
    }
    /**
     * Called by the client port when the number of open communications changes from 0 to 1. This
     * usually indicates the `socket.ref()` should be called to prevent the process from exiting.
     */
    onHavingOneOrMoreOpenCommunication() { }
    /**
     * Called by the client port when the number of open communications changes from 1 or more to 0.
     * This usually indicates the `socket.unref()` should be called to allow the process to exit.
     */
    onHavingNoOpenCommunication() { }
}
exports.ClientTransport = ClientTransport;
class ServerTransport extends Transport {
    parseIncomingMessage(message) {
        return clientToServerMessageSchema.parse(message);
    }
    send(message) {
        const result = serverToClientMessageSchema.parse(message);
        this.sendViaTransport(result);
    }
}
exports.ServerTransport = ServerTransport;
//

/***/ }),

/***/ 7418:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wsAuthenticationResultSchema = void 0;
const zod_1 = __webpack_require__(6851);
exports.wsAuthenticationResultSchema = zod_1.z.discriminatedUnion("success", [
    zod_1.z.object({
        success: zod_1.z.literal(true),
    }),
    zod_1.z.object({
        success: zod_1.z.literal(false),
        error: zod_1.z.string(),
    }),
]);
//

/***/ }),

/***/ 7929:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.authPacketSchema = void 0;
const zod_1 = __webpack_require__(6851);
exports.authPacketSchema = zod_1.z.object({
    authVersion: zod_1.z.literal(1),
    clientIdentifier: zod_1.z.string().max(256),
    clientPasskey: zod_1.z.string().max(256),
});
//

/***/ }),

/***/ 5305:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KEEP_ALIVE_TIMEOUT = exports.KEEP_ALIVE_INTERVAL = exports.authPacketSchema = exports.ServerTransport = exports.ClientTransport = exports.Channel = exports.BackendInterface = void 0;
var BackendInterface_1 = __webpack_require__(7158);
Object.defineProperty(exports, "BackendInterface", ({ enumerable: true, get: function () { return BackendInterface_1.BackendInterface; } }));
var Channel_1 = __webpack_require__(3142);
Object.defineProperty(exports, "Channel", ({ enumerable: true, get: function () { return Channel_1.Channel; } }));
var Transport_1 = __webpack_require__(5156);
Object.defineProperty(exports, "ClientTransport", ({ enumerable: true, get: function () { return Transport_1.ClientTransport; } }));
Object.defineProperty(exports, "ServerTransport", ({ enumerable: true, get: function () { return Transport_1.ServerTransport; } }));
var authentication_1 = __webpack_require__(7929);
Object.defineProperty(exports, "authPacketSchema", ({ enumerable: true, get: function () { return authentication_1.authPacketSchema; } }));
var timeoutConstants_1 = __webpack_require__(5621);
Object.defineProperty(exports, "KEEP_ALIVE_INTERVAL", ({ enumerable: true, get: function () { return timeoutConstants_1.KEEP_ALIVE_INTERVAL; } }));
Object.defineProperty(exports, "KEEP_ALIVE_TIMEOUT", ({ enumerable: true, get: function () { return timeoutConstants_1.KEEP_ALIVE_TIMEOUT; } }));
//

/***/ }),

/***/ 5621:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KEEP_ALIVE_TIMEOUT = exports.KEEP_ALIVE_INTERVAL = void 0;
exports.KEEP_ALIVE_INTERVAL = 5000;
exports.KEEP_ALIVE_TIMEOUT = 15000;
//

/***/ }),

/***/ 6853:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createLlmBackendInterface = void 0;
const lms_communication_1 = __webpack_require__(5305);
const lms_shared_types_1 = __webpack_require__(5790);
const LLMPredictionConfig_1 = __webpack_require__(7486);
const zod_1 = __webpack_require__(6851);
function createLlmBackendInterface() {
    return new lms_communication_1.BackendInterface()
        .addRpcEndpoint("echo", {
        parameter: zod_1.z.string(),
        returns: zod_1.z.string(),
    })
        .addChannelEndpoint("loadModel", {
        creationParameter: zod_1.z.object({
            path: zod_1.z.string(),
            identifier: zod_1.z.string().optional(),
            preset: zod_1.z.string().optional(),
            config: lms_shared_types_1.llmLoadModelConfigSchema,
            acceleration: lms_shared_types_1.llmAccelerationConfigSchema,
            noHup: zod_1.z.boolean(),
        }),
        toClientPacket: zod_1.z.discriminatedUnion("type", [
            zod_1.z.object({
                type: zod_1.z.literal("progress"),
                progress: zod_1.z.number(),
            }),
            zod_1.z.object({
                type: zod_1.z.literal("success"),
                sessionIdentifier: zod_1.z.string(),
            }),
        ]),
        toServerPacket: zod_1.z.discriminatedUnion("type", [
            zod_1.z.object({
                type: zod_1.z.literal("cancel"),
            }),
        ]),
    })
        .addRpcEndpoint("unloadModel", {
        parameter: zod_1.z.object({
            identifier: zod_1.z.string(),
        }),
        returns: zod_1.z.void(),
    })
        .addChannelEndpoint("predict", {
        creationParameter: zod_1.z.object({
            modelSpecifier: lms_shared_types_1.llmModelSpecifierSchema,
            history: lms_shared_types_1.llmChatHistorySchema,
            config: LLMPredictionConfig_1.llmFullPredictionConfigSchema,
            structured: lms_shared_types_1.llmStructuredPredictionSettingSchema.optional(),
        }),
        toClientPacket: zod_1.z.discriminatedUnion("type", [
            zod_1.z.object({
                type: zod_1.z.literal("fragment"),
                fragment: zod_1.z.string(),
            }),
            zod_1.z.object({
                type: zod_1.z.literal("success"),
                stats: lms_shared_types_1.llmPredictionStatsSchema,
                modelInfo: lms_shared_types_1.llmDescriptorSchema,
            }),
        ]),
        toServerPacket: zod_1.z.discriminatedUnion("type", [
            zod_1.z.object({
                type: zod_1.z.literal("cancel"),
            }),
        ]),
    })
        .addRpcEndpoint("listLoaded", {
        parameter: zod_1.z.undefined(),
        returns: zod_1.z.array(lms_shared_types_1.llmDescriptorSchema),
    })
        .addRpcEndpoint("getModelInfo", {
        parameter: zod_1.z.object({
            specifier: lms_shared_types_1.llmModelSpecifierSchema,
        }),
        returns: lms_shared_types_1.llmDescriptorSchema.optional(),
    });
}
exports.createLlmBackendInterface = createLlmBackendInterface;
//

/***/ }),

/***/ 3204:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.downloadedModelSchema = void 0;
const zod_1 = __webpack_require__(6851);
exports.downloadedModelSchema = zod_1.z.discriminatedUnion("type", [
    zod_1.z.object({
        type: zod_1.z.enum(["llm", "embedding"]),
        path: zod_1.z.string(),
        sizeBytes: zod_1.z.number(),
        architecture: zod_1.z.string().optional(),
    }),
]);
//

/***/ }),

/***/ 4284:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromSerializedError = exports.attachSerializedErrorData = exports.serializeError = exports.serializedLMSExtendedErrorSchema = exports.errorDisplayDataSchema = void 0;
const zod_1 = __webpack_require__(6851);
const LLMErrorDisplayData_1 = __webpack_require__(8469);
exports.errorDisplayDataSchema = zod_1.z.discriminatedUnion("code", [...LLMErrorDisplayData_1.llmErrorDisplayDataSchema]);
/**
 * Makes a Zod schema that turns a failed parse into an `undefined`.
 */
function failOk(schema) {
    return zod_1.z.any().transform(val => (schema.safeParse(val).success ? val : undefined));
}
exports.serializedLMSExtendedErrorSchema = zod_1.z.object({
    title: zod_1.z.string(),
    cause: zod_1.z.string().optional(),
    suggestion: zod_1.z.string().optional(),
    errorData: zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()).optional(),
    displayData: failOk(exports.errorDisplayDataSchema).optional(),
});
function serializeError(error) {
    if (typeof error === "object") {
        return {
            title: error.title ?? error.message ?? "Unknown error",
            cause: error.cause,
            suggestion: error.suggestion,
            errorData: error.errorData,
            displayData: error.displayData,
        };
    }
    else {
        return {
            title: String(error),
        };
    }
}
exports.serializeError = serializeError;
/**
 * Attaches the additional error data from a serialized error to an error object.
 */
function attachSerializedErrorData(error, serialized) {
    const untypedError = error;
    if (serialized.cause !== undefined) {
        untypedError.cause = serialized.cause;
    }
    if (serialized.suggestion !== undefined) {
        untypedError.suggestion = serialized.suggestion;
    }
    if (serialized.errorData !== undefined) {
        untypedError.errorData = serialized.errorData;
    }
}
exports.attachSerializedErrorData = attachSerializedErrorData;
function fromSerializedError(error) {
    const result = new Error(error.title);
    result.name = "LMStudioError";
    attachSerializedErrorData(result, error);
    return result;
}
exports.fromSerializedError = fromSerializedError;
//

/***/ }),

/***/ 5221:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.jsonSerializableSchema = void 0;
const zod_1 = __webpack_require__(6851);
exports.jsonSerializableSchema = zod_1.z.any().transform((val, ctx) => {
    try {
        return JSON.parse(JSON.stringify(val));
    }
    catch (e) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: "Not JSON serializable: " + e.message,
        });
        return val;
    }
});
//

/***/ }),

/***/ 8322:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runtimeSchema = exports.acceleratorSchema = exports.acceleratorTypeSchema = void 0;
const zod_1 = __webpack_require__(6851);
exports.acceleratorTypeSchema = zod_1.z.enum(["unknown", "integratedGpu", "dedicatedGpu"]);
exports.acceleratorSchema = zod_1.z.object({
    name: zod_1.z.string(),
    deviceId: zod_1.z.number(),
    totalMemoryBytes: zod_1.z.number(),
    type: exports.acceleratorTypeSchema,
});
exports.runtimeSchema = zod_1.z.object({
    key: zod_1.z.string(),
    name: zod_1.z.string(),
    accelerators: zod_1.z.array(exports.acceleratorSchema),
});
//

/***/ }),

/***/ 5790:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runtimeSchema = exports.acceleratorTypeSchema = exports.acceleratorSchema = exports.reasonableKeyStringSchema = exports.llmStructuredPredictionSettingSchema = exports.llmPredictionStopReasonSchema = exports.llmPredictionStatsSchema = exports.llmFullPredictionConfigSchema = exports.llmContextOverflowPolicySchema = exports.llmCompletionPredictionConfigSchema = exports.llmChatPredictionConfigSchema = exports.llmModelSpecifierSchema = exports.llmModelQuerySchema = exports.llmLoadModelConfigSchema = exports.llmDescriptorSchema = exports.llmChatHistorySchema = exports.llmChatHistoryRoleSchema = exports.llmChatHistoryMessageSchema = exports.llmAccelerationOffloadSchema = exports.llmAccelerationConfigSchema = exports.serializeError = exports.serializedLMSExtendedErrorSchema = exports.fromSerializedError = exports.errorDisplayDataSchema = exports.attachSerializedErrorData = exports.downloadedModelSchema = exports.logLevelSchema = void 0;
const zod_1 = __webpack_require__(6851);
exports.logLevelSchema = zod_1.z.enum(["debug", "info", "warn", "error"]);
var DownloadedModel_1 = __webpack_require__(3204);
Object.defineProperty(exports, "downloadedModelSchema", ({ enumerable: true, get: function () { return DownloadedModel_1.downloadedModelSchema; } }));
var Error_1 = __webpack_require__(4284);
Object.defineProperty(exports, "attachSerializedErrorData", ({ enumerable: true, get: function () { return Error_1.attachSerializedErrorData; } }));
Object.defineProperty(exports, "errorDisplayDataSchema", ({ enumerable: true, get: function () { return Error_1.errorDisplayDataSchema; } }));
Object.defineProperty(exports, "fromSerializedError", ({ enumerable: true, get: function () { return Error_1.fromSerializedError; } }));
Object.defineProperty(exports, "serializedLMSExtendedErrorSchema", ({ enumerable: true, get: function () { return Error_1.serializedLMSExtendedErrorSchema; } }));
Object.defineProperty(exports, "serializeError", ({ enumerable: true, get: function () { return Error_1.serializeError; } }));
var LLMAccelerationConfig_1 = __webpack_require__(2795);
Object.defineProperty(exports, "llmAccelerationConfigSchema", ({ enumerable: true, get: function () { return LLMAccelerationConfig_1.llmAccelerationConfigSchema; } }));
Object.defineProperty(exports, "llmAccelerationOffloadSchema", ({ enumerable: true, get: function () { return LLMAccelerationConfig_1.llmAccelerationOffloadSchema; } }));
var LLMChatHistory_1 = __webpack_require__(6427);
Object.defineProperty(exports, "llmChatHistoryMessageSchema", ({ enumerable: true, get: function () { return LLMChatHistory_1.llmChatHistoryMessageSchema; } }));
Object.defineProperty(exports, "llmChatHistoryRoleSchema", ({ enumerable: true, get: function () { return LLMChatHistory_1.llmChatHistoryRoleSchema; } }));
Object.defineProperty(exports, "llmChatHistorySchema", ({ enumerable: true, get: function () { return LLMChatHistory_1.llmChatHistorySchema; } }));
var LLMDescriptor_1 = __webpack_require__(8540);
Object.defineProperty(exports, "llmDescriptorSchema", ({ enumerable: true, get: function () { return LLMDescriptor_1.llmDescriptorSchema; } }));
var LLMLoadModelConfig_1 = __webpack_require__(5974);
Object.defineProperty(exports, "llmLoadModelConfigSchema", ({ enumerable: true, get: function () { return LLMLoadModelConfig_1.llmLoadModelConfigSchema; } }));
var LLMModelSpecifier_1 = __webpack_require__(4126);
Object.defineProperty(exports, "llmModelQuerySchema", ({ enumerable: true, get: function () { return LLMModelSpecifier_1.llmModelQuerySchema; } }));
Object.defineProperty(exports, "llmModelSpecifierSchema", ({ enumerable: true, get: function () { return LLMModelSpecifier_1.llmModelSpecifierSchema; } }));
var LLMPredictionConfig_1 = __webpack_require__(7486);
Object.defineProperty(exports, "llmChatPredictionConfigSchema", ({ enumerable: true, get: function () { return LLMPredictionConfig_1.llmChatPredictionConfigSchema; } }));
Object.defineProperty(exports, "llmCompletionPredictionConfigSchema", ({ enumerable: true, get: function () { return LLMPredictionConfig_1.llmCompletionPredictionConfigSchema; } }));
Object.defineProperty(exports, "llmContextOverflowPolicySchema", ({ enumerable: true, get: function () { return LLMPredictionConfig_1.llmContextOverflowPolicySchema; } }));
Object.defineProperty(exports, "llmFullPredictionConfigSchema", ({ enumerable: true, get: function () { return LLMPredictionConfig_1.llmFullPredictionConfigSchema; } }));
var LLMPredictionStats_1 = __webpack_require__(6653);
Object.defineProperty(exports, "llmPredictionStatsSchema", ({ enumerable: true, get: function () { return LLMPredictionStats_1.llmPredictionStatsSchema; } }));
Object.defineProperty(exports, "llmPredictionStopReasonSchema", ({ enumerable: true, get: function () { return LLMPredictionStats_1.llmPredictionStopReasonSchema; } }));
var LLMStructuredPredictionSetting_1 = __webpack_require__(5943);
Object.defineProperty(exports, "llmStructuredPredictionSettingSchema", ({ enumerable: true, get: function () { return LLMStructuredPredictionSetting_1.llmStructuredPredictionSettingSchema; } }));
var reasonable_1 = __webpack_require__(4324);
Object.defineProperty(exports, "reasonableKeyStringSchema", ({ enumerable: true, get: function () { return reasonable_1.reasonableKeyStringSchema; } }));
var Runtime_1 = __webpack_require__(8322);
Object.defineProperty(exports, "acceleratorSchema", ({ enumerable: true, get: function () { return Runtime_1.acceleratorSchema; } }));
Object.defineProperty(exports, "acceleratorTypeSchema", ({ enumerable: true, get: function () { return Runtime_1.acceleratorTypeSchema; } }));
Object.defineProperty(exports, "runtimeSchema", ({ enumerable: true, get: function () { return Runtime_1.runtimeSchema; } }));
//

/***/ }),

/***/ 2795:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.llmAccelerationConfigSchema = exports.llmAccelerationOffloadSchema = void 0;
const zod_1 = __webpack_require__(6851);
exports.llmAccelerationOffloadSchema = zod_1.z.union([zod_1.z.number().min(0).max(1), zod_1.z.literal("auto")]);
exports.llmAccelerationConfigSchema = zod_1.z.object({
    offload: zod_1.z.union([exports.llmAccelerationOffloadSchema, zod_1.z.literal("auto")]),
});
//

/***/ }),

/***/ 6427:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.llmChatHistorySchema = exports.llmChatHistoryMessageSchema = exports.llmChatHistoryRoleSchema = void 0;
const zod_1 = __webpack_require__(6851);
exports.llmChatHistoryRoleSchema = zod_1.z.enum(["system", "user", "assistant"]);
exports.llmChatHistoryMessageSchema = zod_1.z.object({
    role: exports.llmChatHistoryRoleSchema,
    content: zod_1.z.string(),
});
exports.llmChatHistorySchema = zod_1.z.array(exports.llmChatHistoryMessageSchema);
//

/***/ }),

/***/ 8540:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.llmDescriptorSchema = void 0;
const zod_1 = __webpack_require__(6851);
exports.llmDescriptorSchema = zod_1.z.object({
    identifier: zod_1.z.string(),
    path: zod_1.z.string(),
});
//

/***/ }),

/***/ 8469:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.llmErrorDisplayDataSchema = void 0;
const zod_1 = __webpack_require__(6851);
const LLMModelSpecifier_1 = __webpack_require__(4126);
exports.llmErrorDisplayDataSchema = [
    zod_1.z.object({
        code: zod_1.z.literal("llm.pathNotFound"),
        path: zod_1.z.string(),
        availablePathsSample: zod_1.z.array(zod_1.z.string()),
        totalModels: zod_1.z.number(),
    }),
    zod_1.z.object({
        code: zod_1.z.literal("llm.identifierNotFound"),
        identifier: zod_1.z.string(),
        loadedModelsSample: zod_1.z.array(zod_1.z.string()),
        totalLoadedModels: zod_1.z.number(),
    }),
    zod_1.z.object({
        code: zod_1.z.literal("llm.specificModelUnloaded"),
    }),
    zod_1.z.object({
        code: zod_1.z.literal("llm.noModelMatchingQuery"),
        query: LLMModelSpecifier_1.llmModelQuerySchema,
        loadedModelsSample: zod_1.z.array(zod_1.z.string()),
        totalLoadedModels: zod_1.z.number(),
    }),
];
//

/***/ }),

/***/ 5974:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.llmLoadModelConfigSchema = void 0;
const zod_1 = __webpack_require__(6851);
exports.llmLoadModelConfigSchema = zod_1.z.object({
    contextLength: zod_1.z.number().int().min(0).optional(),
});
//

/***/ }),

/***/ 4126:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.llmModelSpecifierSchema = exports.llmModelQuerySchema = void 0;
const zod_1 = __webpack_require__(6851);
const reasonable_1 = __webpack_require__(4324);
exports.llmModelQuerySchema = zod_1.z.object({
    identifier: reasonable_1.reasonableKeyStringSchema.optional(),
    path: reasonable_1.reasonableKeyStringSchema.optional(),
});
exports.llmModelSpecifierSchema = zod_1.z.discriminatedUnion("type", [
    zod_1.z.object({
        type: zod_1.z.literal("query"),
        query: exports.llmModelQuerySchema,
    }),
    zod_1.z.object({
        type: zod_1.z.literal("sessionIdentifier"),
        sessionIdentifier: zod_1.z.string(),
    }),
]);
//

/***/ }),

/***/ 7486:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.llmFullPredictionConfigSchema = exports.llmChatPredictionConfigSchema = exports.llmCompletionPredictionConfigSchema = exports.llmContextOverflowPolicySchema = void 0;
const zod_1 = __webpack_require__(6851);
exports.llmContextOverflowPolicySchema = zod_1.z.enum([
    "stopAtLimit",
    "truncateMiddle",
    "rollingWindow",
]);
const llmPredictionConfigBaseSchema = zod_1.z.object({
    maxPredictedTokens: zod_1.z.number().int().min(-1).optional(),
    temperature: zod_1.z.number().min(0).max(1).optional(),
    stopStrings: zod_1.z.array(zod_1.z.string()).optional(),
    contextOverflowPolicy: exports.llmContextOverflowPolicySchema.optional(),
});
exports.llmCompletionPredictionConfigSchema = llmPredictionConfigBaseSchema.extend({
    prePrompt: zod_1.z.string().optional(),
});
exports.llmChatPredictionConfigSchema = llmPredictionConfigBaseSchema.extend({
    inputPrefix: zod_1.z.string().optional(),
    inputSuffix: zod_1.z.string().optional(),
});
exports.llmFullPredictionConfigSchema = zod_1.z.object({
    ...exports.llmCompletionPredictionConfigSchema.shape,
    ...exports.llmChatPredictionConfigSchema.shape,
});
//

/***/ }),

/***/ 6653:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.llmPredictionStatsSchema = exports.llmPredictionStopReasonSchema = void 0;
const zod_1 = __webpack_require__(6851);
exports.llmPredictionStopReasonSchema = zod_1.z.enum([
    "userStopped",
    "modelUnloaded",
    "failed",
    "eosFound",
    "stopStringFound",
    "maxPredictedTokensReached",
    "contextLengthReached",
]);
exports.llmPredictionStatsSchema = zod_1.z.object({
    stopReason: exports.llmPredictionStopReasonSchema,
    tokensPerSecond: zod_1.z.number().optional(),
    numGpuLayers: zod_1.z.number().optional(),
    timeToFirstTokenSec: zod_1.z.number().optional(),
    promptTokensCount: zod_1.z.number().optional(),
    predictedTokensCount: zod_1.z.number().optional(),
    totalTokensCount: zod_1.z.number().optional(),
});
//

/***/ }),

/***/ 5943:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.llmStructuredPredictionSettingSchema = void 0;
const zod_1 = __webpack_require__(6851);
const JSONSerializable_1 = __webpack_require__(5221);
exports.llmStructuredPredictionSettingSchema = zod_1.z.discriminatedUnion("type", [
    zod_1.z.object({
        type: zod_1.z.literal("none"),
    }),
    zod_1.z.object({
        type: zod_1.z.literal("json"),
        jsonSchema: JSONSerializable_1.jsonSerializableSchema.optional(),
    }),
]);
//

/***/ }),

/***/ 4324:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reasonableKeyStringSchema = void 0;
const zod_1 = __webpack_require__(6851);
/**
 * A string that is reasonable to use as a key. For example, as preset name, model path, or model
 * identifier.
 */
exports.reasonableKeyStringSchema = zod_1.z
    .string()
    .min(1)
    .max(1024)
    .refine(value => value !== "__proto__", {
    message: 'For security reasons, "__proto__" is not allowed',
})
    .refine(value => /\p{C}/u.test(value) === false, {
    message: "Control characters are not allowed",
});
//

/***/ }),

/***/ 8103:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createSystemBackendInterface = void 0;
const lms_common_1 = __webpack_require__(2934);
const lms_communication_1 = __webpack_require__(5305);
const lms_shared_types_1 = __webpack_require__(5790);
const zod_1 = __webpack_require__(6851);
function createSystemBackendInterface() {
    return new lms_communication_1.BackendInterface()
        .addRpcEndpoint("echo", {
        parameter: zod_1.z.string(),
        returns: zod_1.z.string(),
    })
        .addRpcEndpoint("listDownloadedModels", {
        parameter: zod_1.z.void(),
        returns: (0, lms_common_1.filteredArray)(lms_shared_types_1.downloadedModelSchema),
    });
}
exports.createSystemBackendInterface = createSystemBackendInterface;
//

/***/ }),

/***/ 390:
/***/ ((module) => {

"use strict";
module.exports = require("@lmstudio/lms-isomorphic");

/***/ }),

/***/ 9272:
/***/ ((module) => {

"use strict";
module.exports = require("boxen");

/***/ }),

/***/ 8033:
/***/ ((module) => {

"use strict";
module.exports = require("chalk");

/***/ }),

/***/ 6392:
/***/ ((module) => {

"use strict";
module.exports = require("immer");

/***/ }),

/***/ 9771:
/***/ ((module) => {

"use strict";
module.exports = require("process");

/***/ }),

/***/ 6851:
/***/ ((module) => {

"use strict";
module.exports = require("zod");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LMStudioClient = void 0;
var lms_client_1 = __webpack_require__(7412);
Object.defineProperty(exports, "LMStudioClient", ({ enumerable: true, get: function () { return lms_client_1.LMStudioClient; } }));

})();

module.exports = __webpack_exports__;
/******/ })()
;